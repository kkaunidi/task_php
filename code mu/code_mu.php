<!-- ;  103 Цепочки операторов объединения с null в PHP
; Операторы объединения можно вызывать друг за другом цепочкой.
;  В следующем примере в переменную запишется либо первый элемент массива, либо второй элемент массива,
;  либо заданная строка, если этих элементов нет:

; <?php
; 	$elem = $arr['test1'] ?? $arr['test2'] ?? 'empty';
; ?>

; Перепишите следующий код через изученный оператор:
; <?php
; 	if (isset($user['name'])) {
; 		$res = $user['name'];
; 	} elseif (isset($user['surname'])) {
; 		$res = $user['surname'];
; 	} else {
; 		$res = '';
; 	}
; ?>
; $res = $user['name']?? $user['surname']?? ''

; // 104 Логические операции в PHP
; Давайте посмотрим на следующий код:
; <?php
; 	$a = 1;
; 	$b = 2;
; 	if ($a == $b) {
; 		var_dump(true);
; 	} else {
; 		var_dump(false);
; 	}
; ?>
; Как вы видите, в данном коде выполняется сравнение переменных a и b и, если они равны, то в консоль выводится true, а если не равны - то false.
; Здесь пришло время открыть вам некоторую неочевидную вещь:
; на самом деле конструкция if не является обязательной для сравнения - сами операторы вида ==, ===, !=, <, > и т.д.
; возвращают своим результатом либо true, либо false.
; Смотрите пример:
; <?php
; 	var_dump(1 == 1); // выведет true
; 	var_dump(1 == 2); // выведет false
; ?>
; Исходя из написанного, код из начала урока можно переписать более простым образом:
; <?php
; 	$a = 1;
; 	$b = 2;
; 	var_dump($a == $b);
; ?>
; Можно не выводить результат сразу, а присвоить его какой-нибудь переменной:
; <?php
; 	$a = 1;
; 	$b = 2;

; 	$res = $a == $b;
; 	var_dump($res);
; ?>

; Пусть даны следующие переменные:
; Используя оператор ==, узнайте, равны ли значения этих переменных или нет.
; <?php
; 	$a = 2 * (3 - 1);
; 	$b = 6 - 2;
; $res = $a == $b;
; var_dump($res);
; ?>
; Пусть даны следующие переменные:
; Используя оператор >, узнайте, больше ли переменная $a, чем $b.
; <?php
; 	$a = 5 * (7 - 4);
; 	$b = 1 + 2 + 7;

; 	$res = $a > $b;
; 	var_dump($res);
; ?>

; // 105 Определение четверти часа в PHP
; Пусть у нас есть переменная $min, в которой хранится количество минут от 0 до 59:
; <?php
; 	$min = 10;
; ?>
; Давайте определим, в какую четверть часа попадает указанное количество минут:
; <?php
; 	$min = 10;
; 	if ($min >= 0 and $min <= 14) {
; 		echo '1 четверть';
; 	}
; 	if ($min >= 15 and $min <= 29) {
; 		echo '2 четверть';
; 	}
; 	if ($min >= 30 and $min <= 44) {
; 		echo '3 четверть';
; 	}
; 	if ($min >= 45 and $min <= 59) {
; 		echo '4 четверть';
; 	}
; ?>

; Решите аналогичную задачу, только определите в какую треть часа попадает указанное количество минут.
; <?php
; 	$min = 25;
; 	if ($min >= 0 and $min <= 19) {
; 		echo '1 -я';
; 	}
; 	if ($min >= 20 and $min <= 39) {
; 		echo '2 -я';
; 	}
; 	if ($min >= 40 and $min <= 59) {
; 		echo '3 -я';
; 	}
; ?>

; // 106 Проверка длины строк и массивов в PHP
; Пусть у нас есть переменная $str, в которой хранится некоторая произвольная строка:
; <?php
; 	$str = '12345';
; ?>
; Давайте напишем условие, которое выведет сообщение на экран, если длина строки равна или больше трех символов:
; <?php
; 	$str = '12345';
; 	if (strlen($str) >= 3) {
; 		echo '!';
; 	}
; ?>

; В переменной $arr содержится некоторый массив с числами.
; Напишите условие, которое проверит, что в массиве 3 элемента.
; Если это так, выведите на экран сумму элементов массива.
; <?php
; $str = '12345';
; if(strlen($str) >= 3){
; 	echo $str[0] + $str[1] + $str[2] + $str[3] + $str[4];
; }

; ?>

; // 107 Проверка символа строки в PHP
; Пусть дана некоторая строка, состоящая из цифр:
; <?php
; 	$str = '12345';
; ?>
; Давайте проверим, равен ли первый символ этой строки числу 1:
; <?php
; 	$str = '12345';

; 	if ($str[0] == 1) {
; 		echo '!';
; 	}
; ?>
; Проверим теперь последний символ на равенство числу 5:
; <?php
; 	$str = '12345';
; 	$last = $str[strlen($str) - 1];
; 	if ($last == 5) {
; 		echo '!';
; 	}
; ?>

; Дана некоторая строка. Проверьте, заканчивается ли она на '0'
; <?php
; $str = '12340';
; $last = $str[strlen($str) - 1];
; if($last == 0) {
; 	echo '0';
; }
; ?>

; // 108 Остаток от деления в PHP
; Пусть у нас есть две переменные с числами:
; <?php
; 	$a = 10;
; 	$b = 3;
; ?>
; Давайте найдем остаток от деления одной переменной на другую:
; <?php
; 	$a = 10;
; 	$b = 3;
; 	echo $a % $b; // выведет 1
; ?>
; Пусть теперь в переменных хранятся такие значения, что одна переменная делится на вторую нацело:
; <?php
; 	$a = 10;
; 	$b = 5;
; 	echo $a % $b; // выведет 0
; ?>
; Давайте напишем скрипт, который будет проверять, делится ли нацело одно число на второе:
; <?php
; 	$a = 10;
; 	$b = 3;
; 	if ($a % $b === 0) {
; 		echo 'делится нацело';
; 	} else {
; 		echo 'делится с остатком';
; 	}
; ?>
; Пусть теперь требуется, если число делится с остатком, вывести этот остаток на экран:
; <?php
; 	$a = 10;
; 	$b = 3;
; 	if ($a % $b === 0) {
; 		echo 'делится нацело';
; 	} else {
; 		echo 'делится с остатком ' . $a % $b;
; 	}
; ?>
; В приведенном выше коде получается, что остаток вычисляется в двух местах, а это не оптимально.
; Поправим проблему:
; <?php
; 	$a = 10;
; 	$b = 3;
; 	$rest = $a % $b;
; 	if ($rest === 0) {
; 		echo 'делится нацело';
; 	} else {
; 		echo 'делится с остатком ' . $rest;
; 	}
; ?>

; Как известно, четные числа делятся на 2 без остатка, а нечетные - с остатком. Пусть у вас дано число.
; С помощью оператора % и конструкции if проверьте четное это число или нет.
; <?php
; $num = 10;
; $res = $num % 2;
; if ($res === 0) {
; 	echo 'четное число';
; } else {
; 	echo 'не четное число' . $res;
; }
; ?>

; // 110 Цикл foreach в PHP

; Цикл foreach используется для прохождения по всем элементам массива.
; Синтаксис такой: пишется ключевое слово foreach, а после него круглые скобки ().
; В этих скобках указывается переменная, в которой лежит перебираемый массив, потом слово as,
; а после него - переменная, в которую при каждом проходе цикла будет попадать элемент массива.
; Затем должны идти фигурные скобки {}, в которых будет расположено тело цикла.
; Итак, синтаксис нашего цикла выглядит так:
; <?php
; 	foreach (имяМассива as переменнаяДляЭлемента) {
; 		/*
; 			Код, который находится между фигурными
; 			скобками будет повторяться столько раз,
; 			сколько элементов у массива.
; 		*/
; 	}
; ?>

; // 111 Элементы массива через foreach в PHP

; Давайте с помощью цикла foreach выведем на экран все элементы массива:
; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		echo $elem;
; 	}
; ?>

; // 112 Столбец элементов массива в PHP

; А теперь сделаем так, чтобы элементы массива выводились не в строчку, а получился столбец.
; Для этого при выводе элемента массива будем ставить после него тег br:
; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		echo $elem . '<br>';
; 	}
; ?>

; Дан массив:
; Выведите столбец элементов этого массива на экран.
; <?php
; 	$arr = ['a', 'b', 'c', 'd', 'e'];
; 	foreach ($arr as $elem) {
; 		echo $elem . '<br>';
; 	}
; ?>

; // 113 Квадраты чисел в PHP

; Переберем массив с числами циклом и выведем на экран квадраты этих чисел:
; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		echo $elem * $elem . '<br>';
; 	}
; ?>

; // 114 Накопление суммы в PHP

; Давайте с помощью цикла найдем сумму элементов массива. Для этого используем уже изученный нами прием для накопления результата в цикле:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$res = 0;

; 	foreach ($arr as $elem) {
; 		$res += $elem;
; 	}

; 	echo $res;
; ?>

; Найдите среднее арифметическое его элементов.
; <?php
; 	$arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
; 	$res = 0;
; 	foreach($arr as $elem) {
; 		$res += $elem;
; 	}
; 	echo $res / count($arr);
; ?>

; // 115 Получение ключей в цикле foreach в PHP

; В цикле foreach можно получать не только элементы перебираемого массива, но и ключи.
; В таком случае после as следует указать такую конструкцию: $ключ => $элемент.
; В переменной $ключ будут хранится ключи, а в переменной $элемент - соответствующие этим ключам элементы.
; Чтобы посмотреть на практике, как работать с ключами, давайте сделаем следующее - при каждом проходе цикла
; будем выводить на экран ключ массива и соответствующий ему элемент через дефис:
; <?php
; 	$arr = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5];

; 	foreach ($arr as $key => $elem) {
; 		echo $key.'-'.$elem; // выведет: 'a-1', 'b-2', 'c-3' и так далее...
; 	}
; ?>

; <?php
; 	$arr = ['green' => 'зеленый', 'red' => 'красный','blue' => 'голубой'];
; 	foreach ($arr as $key => $elem) {
; 		echo $key.'-'.$elem . '<br>';
; 	}
; ?>
; С помощью цикла foreach выведите на экран столбец ключей и элементов в формате green - зеленый.

; Дан массив:

; <?php
; 	$arr = ['user1' => 30, 'user2' => 32, 'user3' => 33];
; 	foreach($arr as $key => $elem){
; 		echo $key.'-'.'возраст'.$elem.'лет' . '<br>';
; 	}
; ?>
; С помощью цикла foreach выведите на экран столбец строк такого формата: user1 - возраст 30 лет.

;// 116 Перебор массива и if в PHP

; Внутри цикла foreach можно использовать условие if. Давайте, например, при переборе массива, будем выводить на экран только элементы с четными числами:
; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		if ($elem % 2 == 0) {
; 			echo $elem.'-';
; 		}
; 	}
; ?>

; <?php
; 	$arr = [1, 2, 3, 4, 5];
;     foreach ($arr as $elem) {
;         if($elem % 2 != 0) {
;             echo $elem.'';
;         }
;     }
; ?>
; С помощью цикла foreach и оператора if выведите в консоль нечетные элементы массива.

; Дан массив:
; <?php
; 	$arr = [2, 5, 9, 15, 1, 4];
;     foreach($arr as $elem){
;         if(3 < $elem && $elem < 10) {
;             echo $elem;
;         }
;     }
; ?>
; С помощью цикла foreach и оператора if выведите в консоль те элементы массива, которые больше 3-х, но меньше 10.

; Дан массив с числами. Числа могут быть положительными и отрицательными. Найдите сумму положительных элементов массива.
;  <?php
; $arr = [2, 5, -9, 15, -1, 4];
; $res = 0 ;
; foreach($arr as $elem){
;     if($elem > 0){
;     $res += +$elem;
;     }
; }
; echo $res.'<br>';
; ?>

; <?php
; 	$arr = [10, 20, 30, 50, 235, 3000];
;     foreach($arr as $elem){
;     $elem=(string) $elem;
;     if($elem[0]==1 or $elem[0]==2 or $elem[0]==5){
;         echo $elem.' ';
;     }
; }
; ?>
; Выведите на экран только те числа из массива, которые начинаются на цифру 1, 2 или 5.

; Составьте массив дней недели. С помощью цикла foreach выведите все дни недели, а выходные дни выведите жирным.
; <php?
; $arr = ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
; foreach ($arr as $elem){
;     if($elem == 'вс'or $elem =='сб'){
;         echo '<b>'.$elem.'</b>';
; }
; else{
;  echo $elem;
;     }
; }
; ?>

; Задание:Составьте массив дней недели. С помощью цикла foreach выведите все дни недели, субботу и воскресенье жирным,
; а текущий день выведите курсивом (если это суббота или воскресенье то отобразить и жирным и курсивом).
; Текущий день должен храниться в переменной $day.
; <?php
; $day='вс';
; $arr=['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
; foreach ($arr as $value) {
;     if ($value=='сб' or $value=='вс' and $value==$day) {
;             echo '<i><b> '.$value.'</b></i>'.' ';
;     }
;     else {
;         if ($value=='сб' or $value=='вс') {
;             echo '<b>'.$value.'</b>'.' ';
;         }
;         else {
;         if ($value==$day) {
;         echo '<i>'.$value.'</i>';
;         }
;             else {
;             echo ' '.$value.' ';
;             }
;         }
;     }
; }
; ?>

; // 117 Цикл while в PHP

; ?php
; 	while ( пока выражение истинно ) {
; 		выполняем этот код циклически
; 		в начале каждого цикла проверяем выражение в круглых скобках
; 	}
; ?>
; Цикл закончится, когда выражение перестанет быть истинным. Если оно было ложным изначально - то он не выполнится ни разу.

; Давайте для примера последовательно выведем с помощью цикла while числа от одного до пяти:
; <?php
; 	$i = 1; // задаем какую-нибудь переменную

; 	while ($i <= 5) {
; 		echo $i; // выводим содержимое $i в консоль
; 		$i++;    // увеличиваем $i на единицу при каждом проходе цикла
; 	}
; ?>

; Выведите на экран числа от 11 до 33.
; <php?
; $i = 11;
; while($i <= 33){
;     echo $i;
;     $i++;
; }
; ?>

; 118 Более сложный цикл while в PHP

; К счетчику не обязательно прибавлять единицу. Давайте для примера выведем столбец четных чисел от 2 до 10.
; Для этого начальное значение переменной $i зададим как 2 и будем прибавлять двойку:
; <?php
; 	$i = 2;
; 		while ($i <= 10) {
; 		echo $i;
; 		$i += 2; // увеличиваем $i на 2 при каждом проходе цикла
; 	}
; ?>

; Выведите на экран четные числа в промежутке от 0 до 100.
; <php?
; $i = 0;
; while($i <= 100){
;     echo $i;
;     $i +=2;
; }
; ?>

; 119 Обратный отсчет в цикле while в PHP

; Счетчик не обязательно должен увеличиваться в цикле. Бывают и обратные ситуации, когда счетчик, наоборот, уменьшается.
; Давайте для примера выведем столбец чисел от 10 до 1:
; <?php
; 	$i = 10; // начальное значение 10
; 		while ($i >= 1) { // пока $i больше 1
; 		echo $i;
; 		$i--; // уменьшаем $i на единицу
; 	}
; ?>

; Выведите на экран числа от 30 до 0.
; <php?
; $i = 30;
; while($i >=0){
;     echo $i;
;     $i--;
; }
; ?>

; 120 Ошибки начинающих при работе с циклом while в PHP

; <?php
; 	$test = true;

; 	while ($test === true) {
; 		/*
; 			Написанный здесь код будет выполняться "вечно"
; 			(пока скрипт не будет остановлен принудительно).
; 		*/
; 	}
; ?>

; 123 Изначально неверное условие в цикле while в PHP

; 125 Цикл for в PHP

; Цикл for является альтернативой while. Он более сложен для понимания, но чаще всего его любят больше за то, что он занимает меньше строчек.
; Вот его синтаксис:
; <?php
; 	for ( начальные команды; условие окончания; команды после прохода ) {
; 		тело цикла
; 	}
; ?>
; Начальные команды - это то, что выполнится перед стартом цикла. Они выполнятся только один раз. Обычно там размещают начальные значения счетчиков.
; Условие окончания - это условие, при котором цикл будет крутится, пока оно истинное. Команды после прохода - это команды, которые будут выполнятся каждый раз
; при окончании прохода цикла. Обычно там увеличивают счетчики.
; Давайте с помощью цикла for выведем последовательно числа от 1 до 9:
; <?php
; 	/*
; 		В начале цикла $i будет равно нулю,
; 		цикл будет выполнятся пока $i <= 9,
; 		после каждого прохода к $i прибавляется единица:
; 	*/
; 	for ($i = 0; $i <= 9; $i++) {
; 		echo $i; // выведет 1, 2... 9
; 	}
; ?>

; С помощью цикла for выведите на экран числа от 1 до 100.
; <php?
; for ($i = 1; $i <=100; $i++){
;     echo $i;
; }
; ?>

; С помощью цикла for выведите на экран четные числа в промежутке от 0 до 100.
; <php?
; for ($i = 2; $i <=100; $i+=2){
;     echo $i;
; }
; ?>

; С помощью цикла for выведите на экран нечетные числа в промежутке от 1 до 99.
; <php?
; for ($i = 1; $i <=99; $i+=2){
;     echo $i;
; }
; ?>

; 126 Накопление результата в цикле PHP

; Давайте с помощью цикла найдем сумму целых чисел от 1 до 100. Для таких задач существует стандартное решение, которое мы сейчас разберем.
; Это решение заключается в том, что циклом перебираются числа и их сумма последовательно записывается в какую-то переменную переменную:
; <?php
; 	$result = 0;
; 		for ($i = 1; $i <= 100; $i++) {
; 		$result = $result + $i;
; 	}
; 		echo $result; // искомая сумма
; ?>
; Как это работает: изначально переменная $result имеет значение 0, затем при первом проходе цикла в нее записывается ее текущее
; содержимое плюс значение счетчика. Получится, что каждую итерацию наша переменная будет расти, постепенно накапливая в себе результат.

; Найдите произведение целых чисел от 1 до 20.
; <php?
; $res = 1;
; for($i = 1; $i <= 20; $i++){
;     $res = $res * $i;
;    }
; echo $res;
; ?>

; Найдите сумму четных чисел от 2 до 100.
; <php?
; $res = 0;
; for($i = 2; $i <= 100; $i+=2){
;     $res = $res + $i;
;    }
; echo $res;
; ?>

; Найдите сумму нечетных чисел от 1 до 99.
; <php?
; $res = 0;
; for($i = 1; $i <= 100; $i+=2){
;     $res = $res + $i;
;    }
; echo $res;
; ?>

; 128 Общий синтаксис цикла for в PHP

; сделаем два счетчика: первый пусть каждую итерацию цикла увеличивается на единицу, а второй - на двойку:

; <?php
; 	for ($i = 0, $j = 0; $i <= 9; $i++, $j += 2) {
; 		echo $i . ' ' . $j . '<br>';
; 	}
; ?>

; 129 Инструкция break в PHP

; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		if ($elem == 3) {
; 			echo 'есть';
; 		}
; 	}
; ?>

; давай завершим цикл, как только нам встретится число 3:
; <?php
; 	$arr = [1, 2, 3, 4, 5];

; 	foreach ($arr as $elem) {
; 		if ($elem == 3) {
; 			echo 'есть';
; 			break; // выйдем из цикла
; 		}
; 	}
; ?>
; Инструкция break может завершать любые циклы: foreach, for, while.

; Дан массив с числами. Запустите цикл, который будет по очереди выводить элементы этого массива в консоль до тех пор,
; пока не встретится элемент со значением 0. После этого цикл должен завершить свою работу.
; <?php
; $arr = [1, 2, 3, 4, 5, 6, 0, 9];
; foreach($arr as $elem){
;     echo $elem;
;     if($elem == 0){
;         break;
;     }
; }
; ?>

; Дан массив с числами. Найдите сумму элементов, расположенных от начала массива до первого отрицательного числа.
; <?php
; $res = 0;
; $arr = [1, 2, 3, 4, 5, 3, 0, -9, 5];
; foreach($arr as $elem){
;  $res += +$elem;
;        if($elem < 0){
;                break;
;     }
;    }
;    echo $res;
; ?>

; Дан массив с числами. Найдите позицию первого числа 3 в этом массиве (считаем, что это число обязательно есть в массиве).
; <?php
; $arr = [1, 2, 3, 4, 5];
; foreach($arr as $key => $elem){
;     if($elem ==3){
; echo $key.'-'.$elem;
;     }
; }
; ?>

; Определите, сколько целых чисел, начиная с числа 1, нужно сложить, чтобы сумма получилась больше 100.
; <?php
; $res = 0;
; for($i =1; $i <= 100; $i++){
;     $res = $res + $i;
;     if($res > 100){
;         break;
;     }

; }
; echo 'количество: '.$i.'<br>';
;     echo 'сумм: '.$res;
; ?>

;  130 Инструкция continue в PHP

;  Пусть у нас дан массив с числами. Давайте переберем его циклом и числа, которые делятся на 2, возведем в квадрат и выведем на экран, а числа, которые делятся на 3,
;  возведем в куб и выведем на экран.
; Вот решение описанной задачи:
; <?php
; 	$arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
; 		foreach ($arr as $elem) {
; 		if ($elem % 2 === 0) {
; 			$res = $elem * $elem;
; 			echo 'kbadro'.$res.'<br>';
; 		} elseif ($elem % 3 === 0) {
; 			$res = $elem * $elem * $elem;
; 			echo 'kub'.$res.'<br>';
; 		}
; 	}
; ?>
; строчка echo $res повторяется два раза

; добавив к нашему if еще условие else, которое будет срабатывать для элементов, не делящихся на 2 и 3, и вызовем там инструкцию continue,
; которая сразу же будет перебрасывать нас на новую итерацию цикла:

; <?php
; 	$arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

; 	foreach ($arr as $elem) {
; 		if ($elem % 2 === 0) {
; 			$res = $elem * $elem;
; 		} elseif ($elem % 3 === 0) {
; 			$res = $elem * $elem * $elem;
; 		} else {
; 			continue; // перейдем на новую итерацию цикла
; 		}
; 				echo $res.'<br>';
; ?>

; 131 Работа с флагами в PHP

; Сейчас мы научимся работать с флагами. Флаг - это специальная переменная, которое может принимать только два значения: true или false.
; С помощью флагов можно решать задачи, проверяющие отсутствие чего-либо: к примеру, можно проверить, что в массиве нет элемента с определенным значением.
; Давайте решим следующую задачу: дан массив с числами, нужно проверить, есть ли в нем элемент со значением 3 или нет. Если есть - выведем 'есть', если нет - выведем 'нет'.

; 132 Проверяем наличие элемента массива в PHP

; Для начала давайте попробуем вывести 'есть'. Для этого переберем все элементы нашего массива и ифом будем спрашивать - равен ли текущий элемент значению 3. Если равен - выведем 'есть':
; <?php
; 	$arr = [1, 2, 3, 4, 5, 3];
; 		foreach ($arr as $elem) {
; 		if ($elem === 3) {
; 			echo 'есть';
; 		}

; 	}
; ?>

; Поправим проблему: завершим цикл с помощью break, если элемент уже найден:

; <?php
; 	$arr = [1, 2, 3, 4, 3, 5];

; 	foreach ($arr as $elem) {
; 		if ($elem === 3) {
; 			echo 'есть';
; 			break;  // завершим цикл
; 		}
; 	}
; ?>

; 133 Проверяем отстутствие элемента массива в PHP

; Затем запустим цикл с ифом так, как мы делали это раньше. Если цикл обнаружит, что в массиве есть элемент 3 - 
то поставим переменную $flag в значение true и выйдем из цикла с помощью break:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$flag = false; // считаем, что элемента 3 нет в массиве
; 		foreach ($arr as $elem) {
; 		if ($elem === 3) {
; 			$flag = true; // элемент есть - переопределим переменную $flag
; 			break;        // выйдем из цикла
; 		}
; 	}
;     Теперь после цикла мы можем сделать иф, который посмотрит на переменную $flag и выведет на экран 'есть' или 'нет':
;     	if ($flag === true) {
; 		echo 'есть';
; 	} else {
; 		echo 'нет';
; 	}
; ?>

; <?php
; 	$arr = ['a', 'b', 'c', 'd', 'e'];
;     $flag = false;
;     foreach($arr as $elem){
;         if($elem === 'c'){
;             $flag = true;
;             break;
;         }
;     }
;     if($flag === true){
;         echo 'yes';
;     }else{
;         echo 'no';
;     }
; ?>
; Проверьте, что в этом массиве есть элемент 'c'. Если есть - выведите 'да', а если нет - выведите 'нет'.

; 134 Произвольное количество итераций в цикле while в PHP

; Бывают задачи, в которых количество итераций цикла не известно заранее. 
К примеру: дано число, нужно делить его на 2 столько раз, пока результат не станет меньше 10.
; Нужно вывести число, которое при этом получится.
; В этом случае мы не знаем количество итераций. Не беда - сделаем условием цикла условие пока число больше 10:
; <?php
; 	$num = 500;

; 	while ($num > 10) {
; 		$num = $num / 2;
; 	}
; 		echo $num; // после цикла получим результат
; ?>

; Дано число $num с неким начальным значением. Умножайте его на 3 столько раз, пока результат умножения не станет больше 1000.
; Какое число получится? Посчитайте количество итераций, необходимых для этого.
; <?php
; 	$num = 1;
; 		while ($num < 1000) {
; 		$num = $num *3;
; 	}
; 		echo $num;
; ?>

; 135 Произвольное количество итераций в цикле for без тела в PHP

; Для решения задачи из предыдущего урока можно использовать и цикл for, но особым образом - без тела:
; <?php
; 	for ($num = 500; $num > 10; $num = $num / 2);
; 	echo $num; // после цикла получим результат
; ?>
; Кстати, при желании легко можно подсчитать количество совершенных циклом операций:
; <?php
; 	for ($num = 500, $i = 0; $num > 10; $num = $num / 2, $i++);
; 	echo $num . ' ' . $i;
; ?>

;Решите предыдущую задачу через цикл for.
; <?php
; 	for ($num = 1, $i = 0; $num < 1000; $num = $num * 3, $i++);
; 	echo $num . ' ' . $i;
; ?>

; 136 Формирование строк через циклы в PHP

; Сейчас мы научимся с помощью цикла формировать строки. Давайте для примера сделаем строку, заполненную десятью буквами 'x'.
; Для этого сделаем переменную $str и при каждом проходе цикла будем добавлять в нее одну букву 'x'.
; После цикла мы получим нужную нам строку:
; <?php
; 	$str = ''; // начальное значение - пустые кавычки
	; 	for ($i = 0; $i < 10; $i++) {
; 		$str = $str . 'x';
; 	}

; 	echo $str; // выведет 'xxxxxxxxxx'
; ?>

; Давайте упростим код, используя сокращенную операцию .=:
; <?php
; 	$str = '';
; 		for ($i = 0; $i < 10; $i++) {
; 		$str .= 'x';
; 	}

; 	echo $str;
; ?>

; С помощью цикла сформируйте строку, заполненную 5-тью нулями.
; <?php
; $str = '';
; for($i = 0; $i < 5; $i++){
;     $str .= 0;
; }
; echo $str;
; ?>

; 137 Формирование строк с цифрами через циклы в PHP

; Давайте теперь сделаем строку '12345'. Задача аналогична задаче с десятью иксами - только прибавлять будем не иксы, а счетчик цикла:
; <?php
; 	$str = '';
; 		for ($i = 1; $i <= 5; $i++) {
; 		$str = $str . $i;
; 	}
; 		echo $str; // выведет '12345'
; ?>

; С помощью цикла сформируйте строку '123456789' и запишите ее в переменную $str. Выведите значение этой переменной на экран.
; <php?
; $str = '';
; for($i = 1; $i <=9; $i++){
;     $str = $str . $i;
; }
; echo $str;
;  ?>

;  С помощью цикла сформируйте строку '987654321' и запишите ее в переменную $str. Выведите значение этой переменной на экран.
; <php?
; 	$str = '';
; 	for ($i = 9; $i >= 1; $i--) {
; 		$str = $str . $i;
; 	}
; 		echo $str;
;  ?>

; С помощью цикла сформируйте строку '-1-2-3-4-5-6-7-8-9-' и запишите ее в переменную $str. Выведите значение этой переменной на экран.
; <php?
; $str = '';
; for($i = 1; $i <=9; $i++){
;     $str =  $str . '-' . $i ;
; }
; echo  $str. '-' ;
;  ?>

; 138 Вложенные циклы в PHP

; Циклы, работу с которыми вы уже знаете, можно вкладывать друг в друга. К примеру, давайте решим следующую задачу: выведем на экран строку:
; 111222333444555666777888999
; Тут одним циклом не обойтись - нужно запустить два вложенных друг в друга цикла: 
первый цикл будет перебирать числа (сначала 1, потом 2, потом 3 и так до 9),
; а второй цикл будет повторять эти числа три раза.
; Давайте реализуем:
; <?php
; 	for ($i = 1; $i <= 9; $i++) {
; 		for ($j = 1; $j <= 3; $j++) {
; 			echo $i;
; 		}
; 	}
; ?>
; Обратите внимание: первый цикл имеет счетчик $i, второй $j, а если будет еще и третий цикл - то у него счетчиком будет переменная $k.
;  Это стандартные общепринятые названия, следует пользоваться именно ими.

; С помощью двух вложенных циклов выведите на экран следующую строку:
; 11 12 13 21 22 23 31 32 33
; <php?
; 	for ($i = 1; $i <= 3; $i++) {
; 		for ($j = 1; $j <= 3; $j++) {
; 			echo ' '. $i.$j;
; 		}
; 	}
; ?>

; 139 Заполнение массивов в PHP

; Пусть у нас есть какой-то массив:
; <?php
; 	$arr = [];
; ?>
; Давайте заполним этот массив какими-нибудь элементами. Можно сделать это вот так:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; ?>
; А можно изначально создать массив пустым, а затем добавить в него данные вот так:
; <?php
; 	$arr = [];
; 		$arr[] = 1;
; 	$arr[] = 2;
; 	$arr[] = 3;
; 	$arr[] = 4;
;	$arr[] = 5;

; 140 Заполнение массивов через цикл for в PHP

; Давайте перепишем наш код так, чтобы заполнением массива занимался цикл for:
; <?php
; 	$arr = [];
; 		for ($i = 0; $i <= 4; $i++) {
; 		$arr[] = $i + 1;
; 	}
; 		var_dump($arr);
; ?>

; С помощью цикла заполните массив числами от 1 до 100.
; <?php
; $arr = [];
; for($i = 0; $i <= 100; $i++){
;     $arr[] = $i + 1;
; }
; var_dump($arr);
; ?>

; 141 Цикл for для массивов в PHP

; На самом деле элементы массива можно перебрать и обычным циклом for.

; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$length = count($arr);

; 	for ($i = 0; $i < $length; $i++) {
; 		echo $arr[$i];
; 	}
; ?>

; <?php
; 	$arr = ['a', 'b', 'c', 'd', 'e'];
;     $length = count($arr);
;     for ($i = 0; $i < $length; $i++){
;         echo $arr[$i];
;     }
; ?>
; С помощью цикла for выведите все эти элементы на экран.

; Применение цикла for для массивов в PHP
; Выведем на экран все элементы массива, кроме нулевого. Для этого начнем счетчик цикла не с нуля, а с единицы:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$length = count($arr);

; 	for ($i = 1; $i < $length; $i++) {
; 		echo $arr[$i];
; 	}
; ?>

; <?php
; 	$arr = ['a', 'b', 'c', 'd', 'e'];
;     $length = count($arr) - 1;
;     for($i = 0; $i < $length; $i++){
;         echo $arr[$i];
;     }
; ?>
; С помощью цикла for выведите на экран все элементы этого массива, кроме последнего.

; <?php
;     	$arr = [1, 2, 3, 4, 5, 6, 7, 8];
;     $length = count($arr) / 2;
;     for($i = 0; $i < $length; $i++){
;         echo $arr[$i];
;     }
; ?>
; С помощью цикла for выведите на экран первую половину элементов этого массива.

; 143 Распространенная ошибка при применении цикла for для массивов в PHP

; В следующем коде подсчет элементов массива вынесен в условие цикла:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 		for ($i = 1; $i < count($arr); $i++) {
; 		echo $arr[$i];
; 	}
; ?>
; На первый взгляд кажется, что этот код лучше, так как мы избавились от лишней переменной $length. На самом деле это не так.
; Дело в том, что в приведенном коде функция count будет заново подсчитывать количество элементов массива каждую интерацию цикла. Это не оптимально.

; 144 Изменение массива в цикле for PHP

; Давайте увеличим каждый элемент этого массива в два раза в цикле
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$length = count($arr);
	; 	for ($i = 0; $i < $length; $i++) {
; 		$arr[$i] = $arr[$i] * 2;
; 	}
; 		var_dump($arr); // выведет [2, 4, 6, 8, 10]
; ?>

; Дан массив с числами. Переберите этот массив циклом и возведите каждый элемент этого массива в квадрат.
; <?php
; $arr = [1, 2, 3, 4, 5, 6];
; $length = count($arr);
; for($i = 0; $i < $length; $i++){
;     $arr[$i] = $arr[$i] * $arr[$i];
; }
; var_dump($arr);
; print_r ($arr);
; ?>

; 145 Сокращенные операции для изменения массива в цикле for PHP

; увеличим каждый элемент массива на 5, используя операцию +=:
; <?php
; 	$arr = [1, 2, 3, 4, 5];
; 	$length = count($arr);
; 		for ($i = 0; $i < $length; $i++) {
; 		$arr[$i] += 5;
; 	}
; 		var_dump($arr); // выведет [6, 7, 8, 9, 10]
; ?>

Дан массив с числами. Переберите этот массив циклом и отнимите от каждого элемента единицу.
<?php
$arr = [1, 2, 3, 4, 5, 6];
$length = count($arr);
for($i = 0; $i < $length; $i++) {
    $arr[$i] -= 1;
}
var_dump($arr);
?> -->
<!-- 146 Практика на массивы в цикле в PHP

Дан следующий массив с работниками и их зарплатами:
Увеличьте зарплату каждого работника на 10%. -->

	<!--<?php
	 // $arr = [
	// 	'employee1' => 100,
	// 	'employee2' => 200,
	// 	'employee3' => 300,
	// 	'employee4' => 400,
	// 	'employee5' => 500,
	// 	'employee6' => 600,
	// 	'employee7' => 700,
	// ];

	// foreach ($arr as $elem){
	// 	$elem = $elem  + $elem*0.1;
	// 	echo'<pre>';
	// 	print_r($elem);
	// 	echo'</pre>';
	// }
	// echo'<pre>';
	//   print_r($elem);
	//   echo'</pre>'; -->
?>
<!--
	Модифицируйте предыдущую задачу так, чтобы зарплата увеличивалась только тем работникам, у которых она меньше или равна 400. -->
	<!-- <?php
	$arr = [
		'employee1' => 100,
		'employee2' => 200,
		'employee3' => 300,
		'employee4' => 400,
		'employee5' => 500,
		'employee6' => 600,
		'employee7' => 700,
	];
	foreach($arr as $elem){
		if($elem <= 400){
			$elem = $elem  + $elem*0.1;
		}
		echo'<pre>';
	 	print_r($elem);
	 	echo'</pre>';
	}
	?> -->
	<!-- Дан следующий массив: -->

<!-- <?php
	$arr = [1 => 6, 2 => 7, 3 => 8, 4 => 9, 5 => 10];
    foreach ($arr as $key => $elem){
$sumkey += $key;
$sumelem += $elem;
$res = $sumkey / $sumelem;
    }
    echo'<pre>';
print_r($res);
echo'</pre>';
echo 'sumelem' . ' ' . ($sumelem).'<br>';
echo 'sumkey' . ' ' . ($sumkey);
?> -->
<!-- Найдите сумму ключей этого массива и поделите ее на сумму значений. -->

<!-- Дан следующий массив: -->

<!-- <?php
	$arr = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5];
    $arr1 = [];
    $arr2 = [];
    foreach($arr as $key => $elem){
        $arr1[] = $key;
        $arr2[] = $elem;
    }
    echo'<pre>';
    print_r($arr1);
    echo'</pre>';
    echo'<pre>';
    print_r($arr2);
    echo'</pre>';
?> -->
<!-- Запишите ключи этого массива в один массив, а значения - в другой. -->

<!-- Дан следующий массив: -->
<!--
<?php
	$arr = [
		1 => 125,
		2 => 225,
		3 => 128,
		4 => 356,
		5 => 145,
		6 => 281,
		7 => 452,
	];
    $arr2 = [];
    foreach($arr as $key => $elem){
        $elem = (string)$elem;
        if($elem[0]==1 or $elem[0]==2){
            $arr2[] = $elem;
        }

    }
    echo'<pre>';
    print_r($arr2);
    echo'</pre>';
?> -->
<!-- Запишите в новый массив элементы, значение которых начинается с цифры 1 или цифры 2.
То есть у вас в результате получится вот такой массив:
[
		125,
		225,
		128,
		145,
		281,
	]; -->

     <!-- 147 Отработка циклов PHP -->

<!-- Выведите с помощью цикла столбец чисел от 1 до 100. -->
<!-- <?php
$arr = [];
for($i = 0; $i<= 100; $i++){
    $arr[] = $i + 1;
}
echo'<pre>';
print_r($arr);
echo'</pre>';
?> -->
<!-- Выведите с помощью цикла столбец чисел от 100 до 1. -->
<!-- <?php
$arr = [];
for($i = 100; $i>=1; $i--){
    $arr[] = $i;
}
echo'<pre>';
print_r($arr);
echo'</pre>';
?> -->

<!-- Выведите с помощью цикла столбец четных чисел от 1 до 100. -->
<!-- <?php
$arr = [];
for($i = 1; $i<= 100; $i++){
    if($i%2==0){
    $arr[] = $i;
    }
}
echo'<pre>';
print_r($arr);
echo'</pre>';
?> -->

<!-- Заполните массив 10-ю иксами с помощью цикла. -->
<!-- <?php
$arr = [];
for($i = 1; $i<= 10; $i++){
    $arr[] = 'x';
}
echo'<pre>';
print_r($arr);
echo'</pre>';
?> -->

<!-- Дан массив с числами. С помощью цикла выведите только те элементы массива, которые больше нуля и меньше 10-ти. -->
<!-- <?php
$arr = [1, 5, 8, 12, 8 , 9, 33, 0, -1, 42];
$length = count($arr);
for($i=0; $i<=$length; $i++){
    if($arr[$i] > 0 and $arr[$i]<10){
        echo'<pre>';
print_r($arr[$i]);
echo'</pre>';
    }
}
?> -->
<!-- Дан массив с числами. С помощью цикла проверьте, что в нем есть элемент со значением 5. -->
<!-- <?php
$arr = [1, 5, 8, 12, 8 , 9, 33, 0, -1, 42];
$flag = false;
foreach ($arr as $elem){
    if($elem == 5){
        $flag = true;
        break;
    }
}
if($flag == true){
    echo 'yes';
} else{
    echo 'no';
}
?> -->

<!-- Дан массив с числами. С помощью цикла найдите сумму элементов этого массива. -->
<!-- <?php
$arr = [1, 5, 8, 12, 8 , 9, 33, 0, -1, 42];
$sum;
$length = count($arr);
for($i =0; $i <= $length; $i++){
    // $sum += $arr[$i];
}
echo $sum;
?> -->

<!-- Дан массив с числами. С помощью цикла найдите сумму квадратов элементов этого массива. -->
<!-- <?php
$arr = [1, 5, 8, 12, 8 , 9, 33, 0, -1, 42];
$sum;
$length = count($arr);
for($i =0; $i <= $length; $i++){
    // $sum += $arr[$i]*$arr[$i];
}
echo $sum;
?> -->
<!-- Дан массив с числами. Найдите среднее арифметическое его элементов (сумма элементов, делить на количество). -->
<!-- <?php
$arr = [1, 5, 8, 12, 8 , 9, 33, 0, -1, 42];
$sum;
$length = count($arr);
for($i =0; $i <= $length; $i++){
    //$sum += $arr[$i];
    // $res = $sum/$length;
}
//echo $res;
?> -->
<!-- Напишите скрипт, который будет находить факториал числа. Факториал - это произведение всех целых чисел, меньше данного, и его самого. -->
<!-- <?php
$num = 5;
$res = 1;
for($i =1; $i<=$num; $i++){
    $res *=$i;
}
echo $res;
?> -->
<!-- //148 Многомерные массивы в PHP
Элементы массива могут быть не только строками и числами, но и массивами.
В этом случае у нас получится массив массивов или многомерный массив.
В следующем примере массив $arr состоит из трех элементов, в свою очередь являющихся массивами:
<?php
	$arr = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']];
?>
Перепишем в более понятном виде:

<?php
	$arr = [
		['a', 'b', 'c'],
		['d', 'e', 'f'],
		['g', 'h', 'i'],
	];
?> -->
<!-- В зависимости от уровня вложенности массивы могут быть двухмерными - массив массивов,
трехмерными - массив массивов массивов (ну и так далее - четырехмерными, пятимерными и тп).
Приведенный выше массив является двухмерным,
так как внутри одного массива расположены другие подмассивы и уже в этих подмассивах нет других массивов.
Чтобы вывести какой-либо элемент из двухмерного массива следует писать уже не одну пару квадратных скобок, а две: -->
<!-- <?php
	$arr = [
		['a', 'b', 'c'],
		['d', 'e', 'f'],
		['g', 'h', 'i'],
	];

	echo $arr[0][1]; // выведет 'b'
	echo $arr[1][2]; // выведет 'f'
?> -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		['a', 'b', 'c'],
		['d', 'e', 'f'],
		['g', 'h', 'i'],
		['j', 'k', 'l'],
	];
    echo $arr[3][2];
    echo $arr[1][1];
    echo $arr[2][0];
    echo $arr[0][0];
?> -->
<!-- Выведите с его помощью элементы с текстом 'l', 'e', 'g' и 'a'. -->

<!-- Дан следующий массив: -->
<?php
// 	$arr = [[1, 2], [3, 4], [5, 6]];

//     foreach ($arr as $elem){
//         foreach($elem as $elem2){
//             $res += $elem2;
//         }
//     }
//     echo'<pre>';
// print_r($res);
// echo'</pre>';
// ?>
<!-- Найдите сумму всех его элементов. -->

<!-- 149 Трехмерный массив в PHP -->

<!-- Вот пример трехмерного массива: -->
<!-- <?php
	$arr = [
		[
			['a', 'b'],
			['c', 'd'],
		],
		[
			['e', 'f'],
			['g', 'h'],
		],
		[
			['i', 'j'],
			['k', 'l'],
		],
	];
?> -->
<!-- Для вывода элементов из такого массива уже необходимо написать три квадратные скобки: -->
<!-- <?php
	echo $arr[0][0][0]; // выведет 'a'
	echo $arr[2][1][0]; // выведет 'k'
?> -->


<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		[
			[1, 2],
			[3, 4],
		],
		[
			[5, 6],
			[7, 8],
		],
	];
    foreach ($arr as $elem){
        foreach($elem as $elem2){
            foreach($elem2 as $elem3){
           $res += $elem3;
            }
       }
     }
    echo'<pre>';
 print_r($res);
 echo'</pre>';
?> -->
<!-- Найдите сумму всех элементов приведенного массива. -->

<!-- 150 Ассоциативные массивы в PHP -->

<!-- Многомерные массивы также могут быть ассоциативными, например, вот так:
<?php
	$arr = [
		'user1' => [
			'name' => 'name1',
			'age'  => 31,
		],
		'user2' => [
			'name' => 'name2',
			'age'  => 32,
		],
	];
?>
Давайте с помощью этого массива выведем на экран, к примеру, имя второго юзера:
<?php
	echo $arr['user2']['name']; // выведет 'name2'
?> -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		'boys'  => [1 => 'Коля', 2 => 'Вася', 3 => 'Петя'],
		'girls' => [1 => 'Даша', 2 => 'Маша', 3 => 'Лена'],
	];
    echo $arr['girls'][2];
    echo $arr['boys'][1];
?> -->
<!-- Выведите с помощью этого массива имя первого мальчика и имя второй девочки. -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		'ru' => ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
		'en' => ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
	];
    echo $arr['en'][3];
?> -->
<!-- Выведите с помощью этого массива английское название среды. -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		[
			'name'   => 'user1',
			'age'    => 30,
			'salary' => 1000,
		],
		[
			'name'   => 'user2',
			'age'    => 31,
			'salary' => 2000,
		],
		[
			'name'   => 'user3',
			'age'    => 32,
			'salary' => 3000,
		],
	];

        echo $arr[2]['salary'] + $arr[0]['salary'];

?> -->
<!-- Выведите с помощью этого массива сумму зарплат первого и третьего юзера. -->

<!-- 151 Произвольные массивы в PHP -->

<!-- Многомерные массивы не обязательно должны быть такими, как мы рассмотрели выше.
Посмотрите, например, на следующий массив: -->
<!-- <?php
	$arr = [['a', 'b', [1, 2, 3], [4, 5]], ['d', ['e', 'f']]];
?>
Если переписать его в более понятном виде, то мы увидим, что этот массив "неправильный".
В нем рядом с обычными элементами располагаются массивы: -->
<!-- <?php
	$arr = [
		[
			'a', 'b', [1, 2, 3], [4, 5],
		],
		[
			'd', ['e', 'f'],
		],
	];
?> -->
<!--
Дан следующий массив: -->
<!-- <?php
	$arr = [
        [1, 2, 3,
        [4, 5,
        [6, 7]
        ]
        ],
        [8,
        [9, 10]]
        ];

    echo $arr[0][0] + $arr[0][1] +$arr[0][2] + $arr[0][3][0] + $arr[0][3][1] + $arr[0][3][2][0] + $arr[0][3][2][1] + $arr[1][0] + $arr[1][1][0] + $arr[1][1][1];

?> -->
<!-- Найдите сумму всех элементов приведенного массива. Обращайтесь к каждому элементу по отдельности, без цикла. -->

<!-- 152 Перебор многомерных массивов в PHP -->

<!-- Давайте теперь научимся делать перебор многомерных массивов с помощью циклов. Пусть у нас дан следующий массив:
<?php
	$arr = [
		['a', 'b', 'c'],
		['d', 'e', 'f'],
		['g', 'h', 'i'],
	];
?>
Как вы видите, этот массив двухмерный, а это значит, что для его перебора нужно два вложенных цикла foreach:
<?php
	foreach ($arr as $sub) {
		foreach ($sub as $elem) {
			echo $elem;
		}
	}
?> -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [[1, 2, 3], [4, 5, 6, 7], [8, 9]];
    foreach($arr as $sub){
        foreach($sub as $elem){
            $sum += $elem;
        }
    }
    echo $sum;
?> -->
<!-- С помощью двух вложенных циклов найдите сумму элементов этого массива. -->

 <!-- 153 Перебор трехмерного массива в PHP -->

<!-- А вот для перебора трехмерного массива уже нужно использовать три вложенных цикла. Пусть для примера у нас дан вот такой массив:
<?php
	$arr = [
		[
			['a', 'b'],
			['c', 'd'],
		],
		[
			['e', 'f'],
			['g', 'h'],
		],
		[
			['i', 'j'],
			['k', 'l'],
		],
	];
?>
Давайте выведем все его элементы на экран:
<?php
	foreach ($arr as $sub) {
		foreach ($sub as $subsub) {
			foreach ($subsub as $elem) {
				echo $elem;
			}
		}
	}
?> -->

<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		[
			[1, 2, 3],
			[6, 7, 8],
			[3, 8, 4],
			[6, 7, 9],
		],
		[
			[9, 1, 2],
			[4, 5, 6],
		],
		[
			[9, 1, 2],
			[4, 5, 6],
			[5, 6, 3],
		],
	];
    foreach($arr as $sub){
        foreach($sub as $subsub){
            foreach($subsub as $elem){
                $sum += $elem;
            }
        }
    }
    echo $sum;
?> -->
<!-- С помощью трех вложенных циклов найдите сумму элементов этого массива. -->

<!-- 154 Работа с ключами в многомерных массивах в PHP -->

<!-- Работа с ключами при переборе многомерных массивов осуществляется также, как и при переборе одномерных.
Пусть для примера дан вот такой массив: -->
<!-- <?php
	$arr = [
		'user1' => [
			'name' => 'name1',
			'age'  => 31,
		],
		'user2' => [
			'name' => 'name2',
			'age'  => 32,
		],
	];
?>
Давайте переберем его вложенными циклами и выведем его элементы с ключами в формате ключ ключ элемент: -->
<!-- <?php
	foreach ($arr as $key1 => $sub) {
		foreach ($sub as $key2 => $elem) {
			// echo $key1 . ' ' . $key2 . ' ' . $elem . '<br>';
		}
	}
?>  -->


<!-- Дан следующий массив: -->
<!-- <?php
	$arr = [
		[
			'name'   => 'user1',
			'age'    => 30,
			'salary' => 1000,
		],
		[
			'name'   => 'user2',
			'age'    => 31,
			'salary' => 2000,
		],
		[
			'name'   => 'user3',
			'age'    => 32,
			'salary' => 3000,
		],
	];
    foreach($arr as $key1 => $sub){
        foreach($sub as $key2 => $elem){
            echo'<pre>';
            print_r($key1 . ''. $key2 . '' . $elem);
            echo'</pre>';
        }
    }
?> -->
<!-- Выведите элементы этого массива в формате ключ-значение. -->

<!-- <?php
	$arr = [
		'group1'  => ['user11', 'user12', 'user13', 'user43'],
		'group2'  => ['user21', 'user22', 'user23'],
		'group3'  => ['user31', 'user32', 'user33'],
		'group4'  => ['user41', 'user42', 'user43'],
		'group5'  => ['user51', 'user52'],
	];
    foreach($arr as $key1 => $sub){
        foreach($sub as $key2 => $elem){
            echo '<pre>';
print_r($key1 . '-' . $elem);
            echo '</pre>';
        }
    }
?> -->
<!-- С помощью двух вложенных циклов выведите элементы этого массива в формате имя группы - имя юзера. -->

<!--
155 Заполнение многомерных массивов PHP -->

<!-- Пусть теперь мы хотим в цикле создать какой-нибудь многомерный массив с числами.
Например, вот такой двухмерный массив: -->

<!-- <?php
	[[1, 2, 3], [1, 2, 3], [1, 2, 3]]
?> -->
<!-- Решим поставленную задачу, применив два вложенных цикла. Внешний цикл будет создавать подмассивы,
 а внутренний - заполнять эти подмассивы числами: -->
<!-- <?php
	$arr = [];

	for ($i = 0; $i < 3; $i++) {
		for ($j = 0; $j < 3; $j++) {
			$arr[$i][$j] = $j + 1; // заполняем подмассив числами
		}
	}
    echo '<pre>';
    print_r($arr);
     echo '</pre>';
?> -->

<!-- Сформируйте с помощью двух вложенных циклов следующий массив:
[[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]] -->
<!-- <?php
$arr = [];
for($i = 0; $i<3; $i++){
    for($j = 0; $j <5; $j++){
        $arr[$i][$j] = $j + 1;
    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
?> -->

<!-- Сформируйте с помощью двух вложенных циклов следующий массив:
[['x', 'x', 'x', 'x'], ['x', 'x', 'x', 'x'], ['x', 'x', 'x', 'x']] -->
<!-- <?php
$arr = [];
for($i = 0; $i<3; $i++){
    for($j = 0; $j <4; $j++){
        $arr[$i][$j] = 'x';
    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
?> -->

<!-- Сформируйте с помощью трех вложенных циклов следующий массив:
[
	[
		[1, 2, 3, 4, 5],
		[1, 2, 3, 4, 5],
	],
	[
		[1, 2, 3, 4, 5],
		[1, 2, 3, 4, 5],
	],
	[
		[1, 2, 3, 4, 5],
		[1, 2, 3, 4, 5],
	],
] -->
<!-- <?php
$arr = [];
for($i = 0; $i<3; $i++){
    for($j = 0; $j <2; $j++){
       for($k = 0; $k<5; $k++){
        $arr[$i][$j][$k] = $k + 1;
       }
    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
?> -->

<!-- 156 Заполнение многомерных массивов числами по порядку в PHP -->

<!-- В предыдущих примерах все числа в подмассивах были одинаковыми. Давайте теперь сделаем так, чтобы числа возрастали, вот так:
<?php
	[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
?>
Для этого нужно сделать специальную переменную-счетчик, которая будет увеличивать свое значение на 1 при
каждой итерации внутреннего цикла. Значение этого счетчика мы и будем записывать в массив, вот так: -->
<!-- <?php
	$arr = [];
	$k = 1; // счетчик

	for ($i = 0; $i < 3; $i++) {
		for ($j = 0; $j < 3; $j++) {
			$arr[$i][$j] = $k; // записываем счетчик
			$k++; // увеличиваем счетчик
		}
	}

	var_dump($arr);
?> -->

<!-- Можно уменьшить код, занеся определение счетчика в первый цикл, а k++ - во второй:
<?php
	$arr = [];
	for ($i = 0, $k = 1; $i < 3; $i++) {
		for ($j = 0; $j < 3; $j++, $k++) {
			$arr[$i][$j] = $k;
		}
	}
	var_dump($arr);
?> -->

<!-- Можно также сделать увеличение счетчика после присваивания:
<?php
	$arr = [];
	for ($i = 0, $k = 1; $i < 3; $i++) {
		for ($j = 0; $j < 3; $j++) {
			$arr[$i][$j] = $k++;
		}
	}
	var_dump($arr);
?>
Обратите внимание на то, что в данном случае должно быть обязательно k++,
а не ++k, так как второй вариант сначала выполнит увеличение счетчика,
а уже потом запись в массив (то есть в результате массив начнется с двойки, а не с единицы). -->

<!-- Сформируйте с помощью двух вложенных циклов следующий массив:
<!-- <?php
	[[1, 2], [3, 4], [5, 6], [7, 8]]
?>
<!-- <?php
$arr = [];
for($i=0, $k = 1; $i < 4; $i++){
    for($j =0; $j<2; $j++){
        $arr[$i][$j] = $k++;
    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
 ?> -->

<!-- Сформируйте с помощью двух вложенных циклов следующий массив:
<?php
	[[2, 4, 6], [8, 10, 12], [14, 16, 18], [20, 22, 24]]
?> -->
<!-- <?php
$arr = [];
for($i=0, $k = 1; $i < 4; $i++){
    for($j =0; $j<3; $j++){
        $arr[$i][$j] = 2*$k++;
    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
 ?> -->

<!-- Сформируйте с помощью трех вложенных циклов следующий трехмерный массив:
<?php
	[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
?> -->
<!-- <?php
$arr = [];
for($i=0, $k = 1; $i < 2; $i++){
    for($j =0; $j<2; $j++){
        for($n = 0; $n<2; $n++){
            $arr[$i][$j][$n] = $k++;
        }

    }
}
echo '<pre>';
print_r($arr);
 echo '</pre>';
 ?> -->

<!-- 157 Массив ассоциативных массивов в PHP -->

<!-- Очень часто в PHP появляются массивы, содержащие набор неких сущностей, например, список пользователей или список продуктов.
Вот пример такого массива: -->
<!-- <?php
	$users = [
		[
			'name'   => 'user1',
			'age'    => 31,
			'salary' => 1000,
		],
		[
			'name'   => 'user2',
			'age'    => 32,
			'salary' => 2000,
		],
		[
			'name'   => 'user3',
			'age'    => 33,
			'salary' => 3000,
		],
	];
?> -->
<!-- Как вы видите, здесь мы имеем дело с массивом ассоциативных массивов.
Не смотря на то, что этот массив двухмерный, как правило для его перебора используется один foreach, перебирающий подмассивы.
А части самих подмассивов просто получают по ключу и записывают в нужном порядке и формате.
Давайте для примера выведем столбец наших работников в некотором формате: -->
<!-- <?php
	foreach ($users as $user) {
		echo $user['name'] . ': ' . $user['salary'] . '$, ' . $user['age'] . '<br>';
	}
?> -->
<!--
<?php
	$products = [
		[
			'name'   => 'мясо',
			'price'  => 100,
			'amount' => 5,
		],
		[
			'name'   => 'овощи',
			'price'  => 200,
			'amount' => 6,
		],
		[
			'name'   => 'фрукты',
			'price'  => 300,
			'amount' => 7,
		],
	];
    foreach($products as $product){
        echo'<pre>';
        print_r( $product['name'] . ': ' . $product['amount'] . ' по цене: ' . $product['price']);
        echo'</pre>';
    }
?> -->
<!-- Выведите с помощью этого массива столбец продуктов в каком-нибудь придуманном вами формате. -->

<!-- 158 Конвертация многомерных массивов в PHP -->

<!-- Пусть у нас есть список юзеров, хранящийся в следующей структуре:

<?php
	$users = [
		[
			'id' => 11,
			'name' => 'name11',
			'surname' => 'surname11',
		],
		[
			'id' => 14,
			'name' => 'name14',
			'surname' => 'surname14',
		],
		[
			'id' => 17,
			'name' => 'name17',
			'surname' => 'surname17',
		],
	];
?> -->
<!-- Давайте напишем код, который переформатирует наш массив вот в такой:
[
	11 => [
		'id' => 11,
		'name' => 'name11',
		'surname' => 'surname11',
	],
	14 => [
		'id' => 14,
		'name' => 'name14',
		'surname' => 'surname14',
	],
	17 => [
		'id' => 17,
		'name' => 'name17',
		'surname' => 'surname17',
	],
]
Решим поставленную задачу с помощью цикла: -->
<!-- <?php
	$res = [];
	foreach ($users as $user) {
		$res[$user['id']] = $user;
	}

    echo'<pre>';
    print_r( $res);
    echo'</pre>';
?> -->

<!-- Дан список городов и их стран, хранящийся в следующей структуре: -->
<!-- <?php
$arr = [
	[
		'country' => 'Россия',
		'city' =>    'Москва',
	],
	[
		'country' => 'Беларусь',
		'city' =>    'Минск',
	],
	[
		'country' => 'Россия',
		'city' =>    'Питер',
	],
	[
		'country' => 'Россия',
		'city' =>    'Владивосток',
	],
	[
		'country' => 'Украина',
		'city' =>    'Львов',
	],
	[
		'country' => 'Беларусь',
		'city' =>    'Могилев',
	],
	[
		'country' => 'Украина',
		'city' =>    'Киев',
	],
];
$res = [];
foreach ($arr as $elem){
    $res[$elem['country']][] = $elem['city'];
}
echo'<pre>';
print_r($res);
echo'</pre>';
?> -->
<!-- Напишите код, которой переделает структуру данных вот в такую:
[
	'Россия'=> [
		'Москва', 'Питер', 'Владивосток',
	],
	'Беларусь'=> [
		'Минск', 'Могилев'
	],
	'Украина'=> [
		'Киев', 'Львов'
	],
] -->

<!-- Дан список событий за определенные даты, хранящийся в следующей структуре: -->
<!-- <?php
$arr = [
	[
		'date'  => '2019-12-29',
		'event' => 'name1'
	],
	[
		'date'  => '2019-12-31',
		'event' => 'name2'
	],
	[
		'date'  => '2019-12-29',
		'event' => 'name3'
	],
	[
		'date'  => '2019-12-30',
		'event' => 'name4'
	],
	[
		'date'  => '2019-12-29',
		'event' => 'name5'
	],
	[
		'date'  => '2019-12-31',
		'event' => 'name6'
	],
	[
		'date'  => '2019-12-29',
		'event' => 'name7'
	],
	[
		'date'  => '2019-12-30',
		'event' => 'name8'
	],
	[
		'date'  => '2019-12-30',
		'event' => 'name9'
	],
];
$res = [];
foreach($arr as $elem){
    $res[$elem['date']][]=$elem['event'];
}
echo'<pre>';
print_r($res);
echo'</pre>';
?> -->
<!-- Напишите код, которой переделает структуру данных вот в такую:
[
	'2019-12-29'=> ['name1', 'name3', 'name5', 'name7'],
	'2019-12-30'=> ['name4', 'name8', 'name9'],
	'2019-12-31'=> ['name2', 'name6'],
] -->

<!-- Дан список событий за определенные даты, хранящийся в следующей структуре: -->
<!-- <?php
$arr = [
	'2019-12-29'=> ['name1', 'name2', 'name3', 'name4'],
	'2019-12-30'=> ['name5', 'name6', 'name7'],
	'2019-12-31'=> ['name8', 'name9'],
];
$res = [];
foreach($arr as $date => $events){
foreach($events as $event){
    $res[] = [
        'date' => $date,
        'event' => $event
    ];
}
}
echo'<pre>';
print_r($res);
echo'</pre>';
?> -->
<!-- Напишите код, которой переделает структуру данных вот в такую: -->

<!-- 159 Математические функции в PHP

Работа со степенью и корнем  sqrt pow-->

<!-- Возведите 2 в 10 степень.
Найдите квадратный корень из 245. -->
<!-- <?php
echo pow(2, 10). '<br>';
echo sqrt(245);
?> -->

<!-- Дан массив:
Найдите корень из суммы квадратов его элементов. Для решения воспользуйтесь циклом foreach. -->
<!-- <?php
	$arr = [4, 2, 5, 19, 13, 0, 10];
	foreach($arr as $elem){
		$sum += pow($elem, 2);
	}
	//echo sqrt($sum);
?> -->

<!-- Работа с функциями округления: round ceil floor -->

<!-- Найдите квадратный корень из 379. Результат округлите до целых, до десятых, до сотых. -->
<!-- <?php
echo round(sqrt(379),1). '<br>';
echo round(sqrt(379),2). '<br>';
echo round(sqrt(379),3). '<br>';
?> -->

<!-- Найдите квадратный корень из 587.
Округлите результат в большую и меньшую сторону, запишите результаты округления в ассоциативный массив с ключами 'floor' и 'ceil' -->
<!-- <?php
echo floor(sqrt(587)). '<br>';
echo ceil(sqrt(587)). '<br>';
echo round(sqrt(587),3). '<br>'
?> -->

<!-- Работа с min и max -->

<!-- Дан массив:
Найдите минимальное и максимальное число. 

<?php
	//$arr = [4, -2, 5, 19, -130, 0, 10];
	//echo min($arr). '<br>';
	//echo max($arr). '<br>';
?>

// Работа с рандомом mt_rand


<!-- Выведите на экран случайное целое число от 1 до 100. 
С помощью цикла заполните массив 10-ю случайными целыми числами. -->
<!-- <?php
for($i=0; $i<=10; $i++){
$arr[] = [mt_rand(1, 100)];
}
echo'<pre>';
print_r($arr); 
echo'</pre>';
?> -->

<!-- Работа с модулем abs -->

<!-- Даны переменные $a и $b. 
Найдите найдите модуль разности $a и $b. Проверьте работу скрипта самостоятельно для различных $a и $b. -->
<!-- <?php
$a = 7;
$b = 44;
echo abs($a-$b);
?> -->

<!-- 160 Строковые функции PHP -->

<!-- Работа с регистром символов strtolower strtoupper ucfirst lcfirst ucwords -->

<!-- Функция strtolower преобразовывает строку в нижний регистр.
Данная функция неправильно работает с кириллицей. 
Используйте функцию mb_strtolower (она работает аналогичным образом, но корректно обрабатывает кириллицу)

Функция strtoupper преобразовывает строку в верхний регистр. mb_strtoupper

Функция ucfirst преобразует первый символ строки в верхний регистр. Не работает с кириллицей.

Функция lcfirst преобразует первый символ строки в нижний регистр. Не работает с кириллицей.

Функция ucwords преобразует первый символ каждого слова в строке в верхний регистр. Не работает с кириллицей-->

<!-- Дана строка 'php'. Сделайте из нее строку 'PHP'. 
Дана строка 'london is the capital of great britain'. 
Сделайте из нее строку 'London Is The Capital Of Great Britain'.
Дана строка 'LONDON'. Сделайте из нее строку 'London'.-->
<!-- <?php
echo strtoupper('php') . '<br>';
echo strtolower('PHP') . '<br>';
echo ucfirst('london') . '<br>';
echo lcfirst('London') . '<br>';
echo ucwords('london is the capital of great britain') . '<br>';
echo ucfirst(strtolower('LONDON')) . '<br>';
?> -->

<!-- Функция strlen
Функция strlen возвращает длину строки (количество символов в строке).
Данная функция неправильно работает с кириллицей. 
Используйте функцию mb_strlen (она работает аналогичным образом, но корректно обрабатывает кириллицу). -->

<!-- Дана строка 'html css php'. Найдите количество символов в этой строке. 
Дана переменная $password, в которой хранится пароль пользователя. 
Если количество символов пароля больше 5-ти и меньше 10-ти, 
то выведите пользователю сообщение о том, что пароль подходит, 
иначе сообщение о том, что нужно придумать другой пароль.-->
<!-- <?php
$password = "ggg5555555g";
if(strlen($password)>5 && strlen($password)<10){
	echo 'пароль подходит';
}else{
echo 'придумайте другой пароль';
}
?> -->

<!-- Функция substr вырезает и возвращает подстроку из строки. Сама строка при этом не изменяется. 
Первым параметром функция принимает строку, вторым - позицию символа, 
откуда следует начинать вырезание, а третьим - количество символов. -->

<!-- Дана строка 'html css php'. Вырежьте из нее и выведите на экран слово 'html', слово 'css' и слово 'php'. 
Дана строка. Проверьте, что она начинается на 'http://'.
Дана строка. Проверьте, что она начинается на 'http://' или на 'https://'.
Дана строка. Проверьте, что она заканчивается на '.png'.
-->
<!-- <?php
$str = 'html css php';
echo substr($str, 0, 4) . '<br>';
echo substr($str, 5, 3) . '<br>';
echo substr($str, -3) . '<br>';
?> -->

<!-- <?php
$str = 'http://my-site.ru';
if(substr($str, 0, 7) === 'http://' ){
	echo 'true';
} else{
	echo substr($str, 0, 7);
}
?> -->
<!-- <?php
$str = 'foto.png';
if(substr($str, -4) === '.png'){
	echo 'true';
}else{
	echo substr($str, -4);
}
?> -->

<!-- Дана строка. Если в этой строке более 5-ти символов - вырежьте из нее первые 5 символов, 
добавьте троеточие в конец и выведите на экран. 
Если же в этой строке 5 и менее символов - просто выведите эту строку на экран. -->

<!-- <?php
$str = '123456';
if(strlen($str) > 5){
	echo substr($str, 0, 5). '...';
}else{
	echo $str;
}
?> -->

<!-- Функция str_replace ищет в строке заданный текст и меняет его на другой. 
Есть также функция str_ireplace, которая делает тоже самое, но без учета регистра. -->

<!-- Дана строка '31.12.2013'. Замените все точки на дефисы.

Дана строка. Замените в ней все буквы 'a' на цифру 1, буквы 'b' - на 2, а буквы 'c' - на 3.-->
<!-- <?php
$str = '31.12.2013';
$str2 = 'aabbbcccdd';
//echo str_replace('.', '-', $str).'<br>';
echo str_replace(['a', 'b', 'c'], [1, 2, 3], $str2).'<br>';
?> -->

<!-- Дана строка с буквами и цифрами, например, '1a2b3c4b5d6e7f8g9h0'. 
Удалите из нее все цифры. То есть в нашем случае должна получится строка 'abcbdefgh' -->
<!-- <?php
$str = '1a2b3c4b5d6e7f8g9h10gggddd';
for( $i=0; $i< strlen($str); $i++){
	$str = str_replace(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],[''], $str);
}
echo $str;
?> -->

<!-- Функция strtr
Функция strtr осуществляет поиск и замену символов в строке. Имеет два варианта работы. -->
<!-- strtr(где меняем, массив замен);
strtr(где меняем, что меняем, на что меняем); -->

<!-- Дана строка $str. Замените в ней все 'a' на цифру 1, буквы 'b' - на 2, а буквы 'c' - на 3. 
Решите задачу двумя способами работы с функцией strtr (массив замен и две строки замен). -->
<!-- <?php
$str = '1a2b3c4b5d6e7f8g9h10gggddd';
echo strtr($str, ['a'=>'1', 'b'=>'2', 'c'=>'3']).'<br>';
echo strtr($str, 'abc', '123').'<br>';
?> -->

<!-- Функция substr_replace
Функция substr_replace заменяет указанную часть строки на другую.  
substr_replace(где меняем, на что меняем, с какого символа, [сколько символов]);-->

<!-- Дана строка $str. Вырежьте из нее подстроку с 3-го символа (отсчет с нуля),
 5 штук и вместо нее вставьте '!!!'. -->

 <!-- <?php
$str = 'fffkl;a;f';
echo substr_replace($str, '!!!', 3, 5);
 ?> -->

<!-- Функция strpos
Функция strpos возвращает позицию первого вхождения подстроки в другую строку. Первым параметром функция принимает строку, в которой осуществляется поиск, 
вторым параметром - подстроку, которую следует искать. 
strpos(где ищем, что ищем, [откуда искать]);-->

<!-- Функция strrpos
Функция strrpos возвращает позицию последнего вхождения подстроки.
strrpos(где ищем, что ищем, [откуда искать]); -->

<!-- Дана строка 'abc abc abc'. Определите позицию первой буквы 'b'.

Дана строка 'abc abc abc'. Определите позицию последней буквы 'b'

Дана строка 'abc abc abc'. Определите позицию первой найденной буквы 'b', 
если начать поиск не с начала строки, а с позиции 3.

Дана строка 'aaa aaa aaa aaa aaa'. Определите позицию второго пробела.

Проверьте, что в строке есть две точки подряд.

Проверьте, что строка начинается на 'http://'.-->
<!-- <?php
echo strpos('abc abc abc', 'b').'<br>';
echo strrpos('abc abc abc', 'b').'<br>';
echo strpos('abc abc abc', 'b', 3).'<br>';
echo strpos('aaa aaa aaa aaa aaa', ' ', 4).'<br>';
if(strpos('aaa..aaa aaa aaa aaa', '...')){
	echo 'true'.'<br>';
}else{
echo 'false'.'<br>';
}

if(strpos('http://my-site.ru', 'http://')===0){
	echo 'true'.'<br>';
}else{
echo 'false'.'<br>';
}
?> -->

<!-- Функция explode
Функция explode разбивает строку в массив по определенному разделителю.
explode(разделитель, строка); -->

<!-- Дана строка 'html css php'. Запишите каждое слово этой строки в отдельный элемент массива. -->
<!-- <?php
$str = 'html css php';
$arr = explode(' ', $str);
echo'<pre>';
print_r($arr); 
echo'</pre>';
?> -->

<!-- Функция implode сливает массив в строку с указанным разделителем.

Синтаксис
implode(разделитель, массив); -->
<!-- <?php
$arr = ['html', 'css', 'php'];
$str = implode('*', $arr);
echo $str.'<br>';
?> -->

<!-- В переменной $date лежит дата в формате год-месяц-день. Преобразуйте эту дату в формат день.месяц.год. -->
<!-- <?php
$date = '2024-06-07';
$arr = explode('-', $date);
$arr = $arr[2]. '.' . $arr[1]. '.' . $arr[0];
echo'<pre>';
print_r($arr); 
echo'</pre>';
?> -->

<!-- Функция str_split разбивает строку в массив. Первым параметром она принимает строку, 
а вторым - количество символов в элементе массива. 
str_split(строка, количество символов в элементе массива);-->

<!-- Давайте найдем сумму цифр числа. Для этого разобьем число в массив с помощью str_split 
и сложим элементы этого массива с помощью array_sum: -->
<!-- <?php
	$num = 12345;
	echo array_sum(str_split($num, 1));
?> -->

<!-- Дана строка '1234567890'. Разбейте ее на массив с элементами '12', '34', '56', '78', '90'. 
Дана строка '1234567890'. Сделайте из нее строку '12-34-56-78-90' не используя цикл.-->
<!-- <?php
$str = 1234567890;
$arr = str_split($str, 2);
$str2 = implode('-', $arr);
echo'<pre>';
print_r($arr); 
echo'</pre>';
echo'<pre>';
print_r($str2); 
echo'</pre>';
?> -->

<!-- Функция trim удаляет пробелы с начала и конца строки. 
Может также удалять другие символы, если их указать вторым параметром.

Функция ltrim удаляет пробелы с начала строки. Подробнее см. функцию trim.

Функция rtrim удаляет пробелы с конца строки. Подробнее см. функцию trim.

trim(строка, [символы]); -->

<!-- Функция удаляет любое количество указанных символов, если они стоят с краю:
<?php
	echo trim('../../abcde...', '/.');
?> -->

<!-- Можно указать диапазон символов с помощью двух точек '..'. 
К примеру, укажем, что мы хотим удалить символы от 'a' до 'd': -->
<!-- <?php
	echo trim('abcde', 'a..d');
?> -->

<!-- Дана строка '/php/'. Сделайте из нее строку 'php', удалив концевые слеши. -->
<!-- <?php
$str = '/php/';
echo trim($str, '/');
?> -->

<!-- Дана строка 'слова слова слова.'. В конце этой строки может быть точка, а может и не быть. 
Сделайте так, чтобы в конце этой строки гарантировано стояла точка. 
То есть: если этой точки нет - ее надо добавить, а если есть - ничего не делать. 
Задачу решите через rtrim без всяких ифов. -->
<!-- <?php
$str = 'слова слова слова.';
$str2 = rtrim($str,'.'). '.';
echo $str2;
?> -->

<!-- Функция strrev переворачивает строку так, чтобы символы шли в обратном порядке.
strrev(строка); -->
<!-- <?php
$str = 123456;
echo strrev($str);
?> -->
<!-- 
Функция str_shuffle переставляет символы в строке в случайном порядке.
str_shuffle(cтрока); -->

<!-- Дана строка. Перемешайте символы этой строки в случайном порядке.

Создайте строку из 6-ти случайных маленьких латинских букв так, чтобы буквы не повторялись. 
Нужно сделать так, чтобы в нашей строке могла быть любая латинская буква, а не ограниченный набор.
-->
<!-- <?php
//$str = 'abcdifghijk';
//echo str_shuffle($str);
$str1 = str_shuffle('abcdifj');
echo $str1;
?> -->

<!-- Функция number_format позволяет форматировать число. В основном используется для того, 
чтобы отделять тройки чисел пробелами, 
к примеру, из 1234567 она может сделать 1 234 567.

number_format(число);
number_format(число, количество знаков);
number_format(число, количество знаков, разделитель дробной части, разделитель тысяч);-->

<!-- В данном примере тройки чисел отделяются запятой, а дробная часть округляется до двух знаков: -->
<!-- <?php
	echo number_format(1234.567, 2);//1,234.57
?> -->

<!-- Дана строка '12345678'. Сделайте из нее строку '12 345 678'. -->
<!-- <?php
echo number_format(12345678,0, ' ', ' ');
?> -->

<!-- Функция str_repeat повторяет строку заданное количество раз.
str_repeat(строка, сколько раз повторить); 

С помощью одного цикла и функции str_repeat выведите на экран следующую пирамидку:-->
<!-- <?php
for($i = 1; $i<=9; $i++){
	echo str_repeat('x', $i). '<br>';
}
?> -->
<!-- С помощью одного цикла и функции str_repeat выведите на экран следующую пирамидку: -->
<!-- <?php
for($i = 1; $i<=9; $i++){
	echo str_repeat($i, $i). '<br>';
}
?> -->

<!-- Функция htmlspecialchars позволяет вывести теги в браузер так, чтобы он не считал их командами, а выводил как строки. 
Функция преобразует амперсанд & в &amp;, уголок < в &lt;, уголок > в &gt;.
htmlspecialchars(строка);

Функция strip_tags удаляет HTML теги из строки, не трогая их содержимого. 
Вторым необязательным параметром можно указать разрешенные теги - они не будут удалены.-->

<!-- Дана строка 'html, <b>php</b>, js'. Удалите теги из этой строки. 
Дана строка 'html, <b>php</b>, js'. 
Выведите ее на экран 'как есть': то есть браузер не должен преобразовать <b> в жирный.
-->
<!-- <?php
$str = 'html, <b>php</b>, <i>js</i>';
echo strip_tags($str). '<br>';
echo strip_tags($str, '<b></b>'). '<br>';
echo htmlspecialchars($str). '<br>';
?> -->

<!-- Функция chr находит символ по его ASCII коду.
chr(код символа); -->

<!-- маленькие латинские буквы имеют коды от 97 до 122. 
Поэтому сгенерируем случайное число в этом диапазоне с помощью mt_rand и результат возьмем в chr: -->
<!-- <?php
	echo chr(mt_rand(97, 122));
?> -->

<!-- Давайте теперь сформируем случайную строку из 6 маленьких латинских букв. 
Для этого описанную в предыдущем примере операцию повторим 6 раз в цикле: -->
<!-- <?php
	$str = '';
	for ($i = 1; $i <= 6; $i++) {
		$str .= chr(mt_rand(97, 122));
	}
	
	echo $str;
?> -->

<!-- Большие латинские буквы имеют диапазон 65-90, а маленькие - 97-122. 
То есть между ними есть дыра. Давайте получим случайный символ маленькую или большую латинскую букву. 
Для этого с помощью range сформируем 2 массива: первый с числами от 65 до 90, а второй с числами от 97 до 122. 
Объединим их вместе с помощью array_merge и затем выведем случайный элемент этого массива с помощью array_rand: -->
<!-- <?php
$str = '';
for ($i = 1; $i <= 6; $i++) {
	$codes = array_merge(range(65, 90), range(97, 122));
	$str .=chr($codes[array_rand($codes)]);
}
echo $str;
?> -->

<!-- Выведите на экран символ с кодом 33. 
Запишите в переменную $str случайный символ - большую букву латинского алфавита. 
-->
<!-- <?php
$str = chr(85);
$len = chr(mt_rand(97, 122)) . chr(mt_rand(97, 122)) . chr(mt_rand(97, 122));
$str .=$len;
	echo $str. '<br>';
?> -->

<!-- Функция strchr находит первое вхождение подстроки в строку и 
возвращает часть строки начиная этого места до конца строки. 
Если второй параметр состоит более чем из одного символа, используется только первый символ.
strchr(где ищем, что ищем); -->

<!-- Давайте достанем адрес страницы без доменного имени из url (вернет подстроку, начиная с первого /, до конца строки) -->
<!-- <?php
	echo strchr('site.ru/folder1/folder2/page.html', '/');
?> -->

<!-- Функция strrchr находит последнее вхождение символа в строку и возвращает часть строки 
начиная с этого места до конца строки. Если второй параметр состоит более чем из одного символа, 
используется только первый символ.
strrchr(где ищем, что ищем); -->

<!-- Дана строка 'ab-cd-ef'. С помощью функции strchr выведите на экран строку '-cd-ef'. 
Дана строка 'ab-cd-ef'. С помощью функции strrchr выведите на экран строку '-ef'.-->
<!-- <?php
echo strchr('ab-cd-ef', '-'). '<br>';
echo strrchr('ab-cd-ef', '-'). '<br>';
?> -->

<!-- Функция strstr находит первое вхождение подстроки в строку и возвращает часть строки 
начиная этого места до конца строки. В отличие от strchr ищет вхождение подстроки из нескольких символов, 
а не вхождение одного символа.
Есть также функция stristr, которая делает тоже самое, но без учета регистра.
strstr(где ищем, что ищем); -->

<!-- Дана строка 'ab--cd--ef'. С помощью функции strstr выведите на экран строку '--cd--ef'. -->
<!-- <?php
echo strstr('ab--cd--ef', '--');
?> -->

<!-- Функции для массивов в PHP

161 Работа с in_array -->

<!-- Функция in_array проверяет наличие заданного элемента в массиве.
in_array(что искать, в каком массиве); -->

<!-- Давайте проверим, есть ли в массиве $arr элемент со значением 3: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	
	$result = in_array('c', $arr);
	var_dump($result);
?> -->

<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = in_array('3', $arr);
	var_dump($result);
?> -->

<!-- Функция array_sum вычисляет сумму элементов массива. -->

<!-- Давайте найдем сумму элементов массива: -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	echo array_sum($arr);
?> -->

<!-- <?php
	$num = 12345;
	echo array_sum(str_split($num, 1));
?> -->
<!-- 
Функция array_product вычисляет произведение (умножение) элементов массива. -->

<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	echo array_product($arr);
?> -->

<!-- Дан массив:Найдите сумму элементов данного массива. -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	echo array_sum($arr) . '<br>';
	echo array_product($arr);
?> -->

<!-- С помощью функций array_sum и count найдите среднее арифметическое элементов (сумма элементов делить на их количество) данного массива. -->
<!-- <?php
$arr = [1, 2, 3, 4, 5];
$length = count($arr);
echo array_sum($arr)/$length;
?> -->

<!-- Функция range создает массив с диапазоном элементов.
range(откуда, докуда, [шаг]); -->

<!-- Давайте создадим массив, заполненный числами от 1 до 5: -->
<!-- <?php
	 echo'<pre>';
	 print_r(range('a', 'z'));
	 echo'</pre>';
	
?> -->

<!-- Создайте строку '1-2-3-4-5-6-7-8-9' не используя цикл. -->
<!-- <?php
$arr = range(1, 9);
$str = implode('-', $arr);
echo $str;
?> -->

<!-- Найдите сумму чисел от 1 до 100 не используя цикл. -->
<!-- Найдите произведение чисел от 1 до 10 не используя цикл. -->
 <!-- <?php
$arr = range(1, 100);
$result = array_sum($arr);
echo $result. '<br>';
echo array_product(range(1, 10));
 ?> -->

<!-- Функция array_merge -->

<!-- Функция array_merge сливает два и более массивов вместе. Если в сливаемых массивах встречаются одинаковые ключи - 
останется только один из таких элементов. 
Если вам нужно, чтобы остались все элементы с одинаковыми ключами - используйте функцию array_merge_recursive. -->

<!-- array_merge(первый массив, второй массив...); -->

<!-- Давайте сольем два массива вместе: -->
<!-- <?php
	$arr1 = ['a', 'b', 'c', 'd', 'e'];
	$arr2 = [1, 2, 3, 4, 5];
	
	$result = array_merge($arr1, $arr2);
	var_dump($result);
?> -->

<!-- Даны массивы:
Сделайте из них массив:	[1, 2, 3, 'a', 'b', 'c'] -->
<!-- <?php
	$arr1 = [1, 2, 3];
	$arr2 = ['a', 'b', 'c'];
	echo'<pre>';
	print_r(array_merge($arr1, $arr2));
	echo'</pre>';

?> -->
<!-- 
Функция array_slice

Функция array_slice отрезает и возвращает часть массива. При этом сам массив не меняется. -->

<!-- array_slice(массив, откуда отрезать, [сколько], [сохранять ключи = true]); -->

<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_slice($arr, 0, 3);
	var_dump($result);
?> -->
<!-- 
Давайте вырежем элементы со второго (имеет номер 1) до конца массива. Для этого третий параметр не пишем: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	
	$result = array_slice($arr, 1);
	var_dump($result);
?> -->

<!-- По умолчанию массив не сохраняет ключи при вырезании: -->
<!-- <?php
	$arr = [1 => 'a', 2 => 'b', 3 => 'c', 4 => 'd', 5 => 'c'];
	$result = array_slice($arr, 0, 3);
	var_dump($result);
?> -->

<!-- Давайте сделаем так, чтобы ключи сохранялись. Для этого последний параметр установим как true: -->
<!-- <?php
	$arr = [1 => 'a', 2 => 'b', 3 => 'c'];
	
	$result = array_slice($arr, 0, 3, true);
	var_dump($result);
?> -->

<!-- Строковые ключи сохраняются при вырезании: -->
<!-- <?php
	$arr = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5];
	$result = array_slice($arr, 0, 3);
	var_dump($result);
?> -->

<!-- С помощью функции array_slice сделайте из него следующий массив: [2, 3, 4] -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = array_slice($arr, 1, 3);
	echo'<pre>';
	print_r($result);
	echo'</pre>';
?> -->

<!-- Функция array_splice

Функция array_splice отрезает и возвращает часть массива. При этом отрезанная часть исчезает из массива. 
Вместо отрезанной части можно вставлять новые элементы. -->

<!-- array_splice(массив, откуда отрезать, [сколько], [вставить взамен]); -->

<!-- Давайте вырежем элементы с первого (имеет номер 0), 3 штуки: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_splice($arr, 0, 3);
	var_dump($result);
	var_dump($arr);
?> -->
<!-- Результат выполнения кода:
['a', 'b', 'c']
При этом массив $arr станет выглядеть так:
['d', 'e'] -->

<!-- Давайте вырежем элементы со второго (имеет номер 1), 2 штуки, а в замен вставим элементы 1, 2, 3: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_splice($arr, 1, 2, [1, 2, 3]);
	var_dump($result);
	echo'<pre>';
	print_r($arr);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
['b', 'c']
При этом массив $arr станет выглядеть так:
['a', 1, 2, 3, 'd', 'e'] -->

<!-- Давайте вообще ничего не будем вырезать, а просто вставим элементы 1, 2, 3 начиная с позиции 1. Для этого третий параметр ставится в ноль: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_splice($arr, 1, 0, [1, 2, 3]);
	var_dump($result);
?> -->
<!-- Результат выполнения кода:
[]
При этом массив $arr станет выглядеть так:
['a', 1, 2, 3, 'b', 'c', 'd', 'e'] -->

<!-- С помощью функции array_splice сделайте из него следующий массив:[1, 4, 5] -->
<!-- <?php
	$arr1 = [1, 2, 3, 4, 5];
	$arr2 = [1, 2, 3, 4, 5];
	$result1 = array_splice($arr1,1,2);
	$result2 = array_slice($arr2,1,2);
	echo'<pre>';
	print_r($arr1);//часть массива исчезает
	echo'</pre>';
	echo'<pre>';
	print_r($arr2);//массив не меняется
	echo'</pre>';
?> -->

<!-- С помощью функции array_splice сделайте из него следующий массив:[1, 2, 3, 'a', 'b', 'c', 4, 5] -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = array_splice($arr,3,0,['a', 'b', 'c'] );
	echo'<pre>';
	print_r($arr);
	echo'</pre>';
?> -->

<!-- Дан массив:С помощью функции array_splice сделайте из него следующий массив:[1, 'a', 'b', 2, 3, 4, 'c',  5, 'e'] -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = array_splice($arr,1,0,['a','b']);
	$result = array_splice($arr, 6, 0, ['c']);
	$result = array_splice($arr, 8, 0, ['e']);
	echo'<pre>';
	print_r($arr);
	echo'</pre>';
?> -->

<!-- Функция array_keys

Функция array_keys получает ключи массива и записывает их в новый массив.
array_keys(массив); -->

<!-- Давайте получим ключи из массива: -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	$result = array_keys($arr);
	echo'<pre>';
	print_r($result);
	echo'</pre>';
	echo'<pre>';
	print_r($arr);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
['a', 'b', 'c', 'd', 'e'] -->

<!-- Функция array_values

Функция array_values выбирает все значения из массива.
array_values(массив); -->

<!-- Давайте получим все значения массива: -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	$result = array_values($arr);
	echo'<pre>';
	print_r($result);
	echo'</pre>';
	echo'<pre>';
	print_r($arr);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
[1, 2, 3, 4, 5] -->

<!-- Функция array_combine

Функция array_combine осуществляет слияние двух массивов в один ассоциативный. 
Первым параметром функция принимает массив будущих ключей, а вторым - массив будущих значений.

array_combine(массив ключей, массив значений); -->

<!-- Давайте сольем два массива в один ассоциативный. При этом соответствующие 
элементы из первого массива станут ключами элементов из второго массива: -->
<!-- <?php
	$keys = ['a' , 'b', 'c', 'd', 'e'];
	$elems = [1, 2, 3, 4, 5];
	$result = array_combine($keys, $elems);
	echo'<pre>';
	print_r($result);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5] -->

<!-- Дан массив:
Запишите в массив $keys ключи из этого массива, а в $values – значения. -->
<!-- <?php
	$arr = ['a' => 1, 'b' => 2, 'c' => 3];
	$keys = array_keys($arr);
	$values = array_values($arr);
	echo'<pre>';
	print_r($keys);
	echo'</pre>';
	echo'<pre>';
	print_r($values);
	echo'</pre>';
?> -->

<!-- Дан массивы: Создайте с их помощью следующий массив:['a' => 1, 'b' => 2, 'c' => 3] -->
<!-- <?php
	$arr1 = ['a', 'b', 'c'];
	$arr2 = [1, 2, 3];
	$result = array_combine($arr1, $arr2);
	echo'<pre>';
	print_r($result);
	echo'</pre>';
?>  -->

<!-- Функция array_flip

Функция array_flip производит обмен местами ключей и значений массива. -->

<!-- Давайте поменяем местами ключи и значения массива: -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	$result = array_flip($arr);
	echo'<pre>';
	print_r($result);
	print_r($arr);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
[1=>'a', 2=>'b', 3=>'c', 4=>'d', 5=>'e'] -->

<!-- Функция array_reverse

Функция array_reverse переворачивает массив в обратном порядке. Первым параметром передается массив, 
а вторым - сохранять ключи при перестановке элементов или нет (true - да, false - нет). 
array_reverse(массив, [сохранять ли ключи]);-->

<!-- Давайте перевернем массив: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_reverse($arr, true);
	echo'<pre>';
	print_r($result);
	print_r($arr);
	echo'</pre>';
?> -->
<!-- Результат выполнения кода:
['e', 'd', 'c', 'b', 'a'] -->

<!-- Дан массив:Поменяйте в нем местами ключи и значения. -->
<!-- <?php
	$arr = ['a' => 1, 'b' => 2, 'c' => 3];
	$result = array_flip($arr);
	echo'<pre>';
	print_r($result);
	print_r($arr);
	echo'</pre>';
?> -->

<!-- Дан массив:Сделайте из него следующий массив:[5, 4, 3, 2, 1] -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = array_reverse($arr);
	echo'<pre>';
	print_r($result);
	print_r($arr);
	echo'</pre>';
?> -->

<!-- Функция array_search

Функция array_search осуществляет поиск значения в массиве и возвращает ключ первого найденного элемента. 
Если такой элемент не найдет - вернет false. Третий параметр задает строгое сравнение по типу (как по ===).
 Если поставить true - он будет сравнивать строго, а если false (по умолчанию) - то нет.

Синтаксис
array_search(что ищем, где ищем, [сравнивать по типу = false]); -->

<!-- Найдем в массиве элемент со значением 'c' - в результате получим его ключ (он равен 2): -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	echo array_search('c', $arr);
?> -->

<!-- Дан массив: Найдите позицию первого элемента '-'. 
 Найдите позицию первого элемента '-' и удалите его с помощью функции array_splice.-->
<!-- <?php
	$arr = ['a', '-', 'b', '-', 'c', '-', 'd'];
	$result = array_search('-', $arr);
	echo'<pre>';
	print_r($result);
	print_r(array_splice($arr, $result, 1));
	print_r($arr);
	echo'</pre>';
?> -->

<!-- Функция array_replace

Функция array_replace заменяет значения первого массива значениями с такими же ключами из других переданных массивов. 
Если ключ из первого массива присутствует во втором массиве, его значение заменяется на значение из второго массива. 
Если ключ есть во втором массиве, но отсутствует в первом - он будет создан в первом массиве. 
Если ключ присутствует только в первом массиве, то сохранится как есть.
Если для замены передано несколько массивов, они будут обработаны в порядке передачи и более поздние массивы 
будут перезаписывать значения из предыдущих. 
array_replace(массив, массив, массив...);-->

<!-- Давайте заменим элемент с ключом 0 на '!', а элемент с ключом 2 - на '!!': -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_replace($arr, [0=>'!', 2=>'!!']);
	echo'<pre>';
	print_r($arr);
	print_r($result);
	echo'</pre>';
?> -->

<!-- Дан массив:Поменяйте элемент с ключом 0 на '!', а элемент с ключом 3 - на '!!'. -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_replace($arr, [0=>'!', 3=>'!!']);
	echo'<pre>';
	print_r($arr);
	print_r($result);
	echo'</pre>';
?> -->

<!-- Сортировка массивов

Для сортировки массивов в PHP существует несколько функций: 
sort - по возрастанию элементов, 
rsort - по убыванию элементов, 
asort - по возрастанию элементов с сохранением ключей, 
arsort - по убыванию элементов с сохранением ключей, 
ksort - по возрастанию ключей, 
krsort - по убыванию ключей, 
usort - по функции по элементам, 
uasort - по функции по элементам с сохранением ключей, 
uksort - по функции по ключам, 
natsort - натуральная сортировка.
Все эти функции изменяют сам массив - это значит, что результат не нужно никуда присваивать: поменяется сам массив. -->

<!-- Давайте отсортируем массив по возрастанию элементов: -->
<!-- <?php
	$arr = [1, 3, 2, 5, 4];
	sort($arr);
	echo'<pre>';
	print_r($arr);
	echo'</pre>'
?> -->

<!-- Дан массив:Попробуйте на нем различные типы сортировок. -->
<!-- <?php
	$arr = ['3'=>'a', '1'=>'c', '2'=>'e', '4'=>'b'];
	//rsort($arr);
	//asort($arr);
	//ksort($arr);
	//usort($arr);
	//natsort($arr);
	echo'<pre>';
	print_r($arr);
	echo'</pre>'
?> -->

<!-- Функция array_rand

Функция array_rand возвращает случайный ключ из массива. Первым параметром задается массив, 
а второй необязательный параметр указывает, сколько случайных ключей следует вернуть. 
Если он не указан - возвращается один ключ, а если указан - заданное количество ключей в виде массива.
Синтаксис
array_rand(массив, [сколько ключей выбрать]); -->

<!-- В данном примере функция вернет случайный ключ из массива: -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	echo array_rand($arr);
?> -->

<!-- Давайте вернем случайный элемент из массива, зная случайный ключ: -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	$key = array_rand($arr);
	echo $arr[$key];
?> -->

<!-- Давайте зададим второй параметр в значение 3 - в этом случае функция вернет массив из 3-х случайных ключей 
(3 ключа - так как второй параметр равен 3): -->
<!-- <?php
	$arr = ['a'=>1, 'b'=>2, 'c'=>3, 'd'=>4, 'e'=>5];
	$keys = array_rand($arr, 3);
	echo'<pre>';
	print_r($keys);
	echo'</pre>';
?> -->

<!-- Дан массив:Выведите на экран случайный ключ из данного массива.
 Выведите на экран случайный элемент данного массива. -->
<?php
	$arr = ['a' => 1, 'b' => 2, 'c' => 3];
	$key = array_rand($arr);
	echo'<pre>';
	print_r($key);
	print_r($arr[$key]);
	echo'</pre>';
?>
<!-- Функции для массивов в PHP

161 Работа с in_array   от 27.07-->

<!-- Функция shuffle осуществляет перемешивание массива так, чтобы его элементы шли в случайном порядке. При этом функция изменяет сам массив:
 это значит результат работы функции не нужно никуда присваивать - изменения произойдут над самим массивом. -->

 <!-- Давайте перемешаем элементы массива в случайном порядке: -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	shuffle($arr);
	echo '<pre>';
	print_r($arr);
	echo '</pre>';
	var_dump($arr);
?> -->

<!-- Заполним массив числами от 1 до 10 так, чтобы они шли в случайном порядке и не повторялись.
Для этого сгенерируем массив с числами от 1 до 10 с помощью range и перетосуем его с помощью shuffle: -->
<!-- <?php
	$arr = range(1, 10);
	shuffle($arr);
	echo '<pre>';
	print_r($arr);
	echo '</pre>';
?> -->

<!-- Сделаем список , заполненный случайными числами от 1 до 10: -->
<!-- <?php
	$arr = range(1, 10);
	shuffle($arr);
	echo '<ul>';
	foreach ($arr as $elem) {
		echo '<li>'.$elem.'</li>';
	}
	echo '</ul>';
?> -->

<!-- Дан массив:
Перемешайте его элементы в случайном порядке. -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$arr2 = range('a','f');
	shuffle($arr2);
	echo '<pre>';
	print_r ($arr2);
	echo '</pre>';
?>  -->

<!-- Функция array_unique осуществляет удаление повторяющихся элементов (дублей) из массива. -->

<!-- Давайте удалим дубли из массива: -->
<!-- <?php
	$arr = [1, 1, 1, 2, 2, 3];
	print_r (array_unique($arr));
?> -->

<!-- Дан массив:Удалите из этого массива повторяющиеся элементы. -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'b', 'a'];
	print_r(array_unique($arr));
?> -->

<!-- Функция array_shift вырезает и возвращает первый элемент массива. При этом этот элемент исчезает из массива. -->
<!--
Давайте вырежем и выведем первый элемент массива: -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	echo '<pre>';
	echo array_shift($arr);
	print_r($arr);
	echo '</pre>';
?> -->

<!-- Функция array_pop вырезает и возвращает последний элемент массива. При этом этот элемент исчезает из массива. -->
<!-- <?php
$arr = [1,2,3,4,5];
echo array_pop($arr);
?> -->

<!-- Функция array_unshift добавляет элементы в начало массива. При этом переданный массив изменяется,
а функция возвращает новое количество элементов в массиве.
Элементы для добавления перечисляются через запятую. -->

<!-- Давайте добавим в начало массива еще 2 элемента: -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$num = array_unshift($arr, 'a', 'b');
	print_r($arr);
?> -->

<!-- Функция array_push добавляет элементы в конец массива. При этом переданный массив изменяется,
а функция возвращает новое количество элементов в массиве.
Элементы для добавления перечисляются через запятую. -->

<!-- Давайте добавим элементы в конец массива: -->
<!-- <?php
	$arr = [1, 2, 3];
	$num = array_push($arr, 4, 5);
	print_r($arr);
?> -->

<!-- Выведите на экран его первый и последний элемент, причем так, чтобы в исходном массиве они исчезли. -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	echo array_shift($arr). '<br>';
	echo array_pop ($arr);
?> -->

<!-- Добавьте ему в начало элемент 0, а в конец - элемент 6. -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$num = array_unshift($arr, 0);
	$num = array_push($arr, 6);
	print_r($arr);
?> -->

<!-- Функция array_pad дополняет массив определенным значением до заданного размера.
Первым параметром функция принимает массив для заполнения, вторым параметром - до какого размера заполнить, третьим - чем заполнять.
Второй параметр можно делать отрицательным - в этом случае массив будет дополнятся элементами не с конца, а с начала.

array_pad(массив, до какого размера заполнить, чем заполнять);
-->

<!-- Давайте заполним массив нулями так, чтобы его размер стал 10 элементов: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_pad($arr, 10, 0);
	print_r($result);
?> -->

<!-- А теперь в массиве уже есть 7 элементов - поэтому он ничем не заполнится: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

	$result = array_pad($arr, 7, 0);
	print_r($result);
?> -->

<!-- Давайте второй параметр сделаем отрицательным. В этом случае массив заполнится сначала, а не с конца: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_pad($arr, -7, 0);
	print_r($result);
?> -->

<!-- Функция array_fill создает массив, заполненный элементами с определенным значением.
 array_fill(ключ первого элемента, сколько элементов, чем заполнять);
-->

<!-- Заполним массив 5-ю элементами с текстом 'x'. Так как первый параметр 0, то ключи начнут свою нумерацию с нуля: -->
<!-- <?php
	print_r(array_fill(0, 5, 'x'));
?> -->

<!-- Функция array_fill_keys создает массив и заполняет массив элементами с определенным значением так,
чтобы весь массив был с одинаковыми элементами, но разными ключами.
Ключи берутся из массива, передаваемого первым параметром.
array_fill_keys(ключ первого элемента, сколько элементов, чем заполнять)
-->

<!-- Заполним массив 5-ю элементами с текстом 'x'. Так как первый параметр 0, то ключи начнут свою нумерацию с нуля: -->
<!-- <?php
	print_r(array_fill_keys(1, [5], 'x'));
?> -->

<!-- Заполним массив 5-ю элементами с текстом 'x' с ключами из массива ['a', 'b', 'c', 'd', 'e']: -->
<!-- <?php
	$arr = array_fill_keys(['a', 'b', 'c', 'd', 'e'], 'x');
	print_r($arr);
?> -->

<!-- Дан массив: $arr = ['a', 'b', 'c']; Сделайте из него следующий массив: ['a', 'b', 'c', '-', '-', '-'] -->
<!-- <?php
	$arr = ['a', 'b', 'c'];
	$result = array_pad($arr, 6, '-');
	print_r($result);
?> -->

<!-- Заполните массив 10-ю буквами 'x'. -->
 <!-- <?php
print_r(array_fill(0, 10, 'x'));
 ?> -->

<!-- Функция array_chunk разбивает одномерный массив в двухмерный. Первым параметром она принимает массив, 
а вторым - количество элементов в каждом подмассиве.
array_chunk(массив, по сколько элементов); -->

<!-- Давайте разобьем массив по два элемента в подмассиве: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd'];
	
	$result = array_chunk($arr, 2);
	echo '<pre>';
	print_r($result);
	echo '</pre>';
?> -->

<!-- Давайте разобьем массив по 3 элемента в подмассиве. 
Обратите внимание на то, что в последнем подмассиве два элемента, а не 3, так как ему не хватило элементов: -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'd', 'e'];
	$result = array_chunk($arr, 3);
	echo '<pre>';
	print_r($result);
	echo '</pre>';
?> -->

<!-- Создайте массив, заполненный целыми числами от 1 до 25. 
С помощью функции array_chunk разбейте этот массив на 5 подмассивов по пять элементов в каждом. -->
<!-- <?php
$arr = range(1,25);
$result = array_chunk($arr,5);
echo '<pre>';
	print_r($result);
	echo '</pre>';
?> -->

<!-- Функция array_count_values производит подсчет количества всех значений массива. Возвращает ассоциативный массив,
 в котором ключами будут элементы массива, а значениями - их количество в массиве. 
 array_count_values(массив);-->

 <!-- Подсчитаем, сколько раз встречается каждый из элементов: -->
<!-- <?php
	$arr = ['a', 'a', 'a', 'b', 'b', 'c'];
	print_r(array_count_values($arr));
?> -->
<!-- Результат выполнения кода:
['a'=>3, 'b'=>2, 'c'=>1] -->

<!-- Дан массив: Подсчитайте сколько раз встречается каждая из букв. -->
<!-- <?php
	$arr = ['a', 'b', 'c', 'b', 'a'];
	print_r(array_count_values($arr))
?> -->

<!-- Функция array_map применяет заданную функцию ко всем элементам массива и возвращает измененный массив. 
Первым параметром функция принимает имя функции, а вторым - массив.
 Можно передавать дополнительные массивы третьим и так далее параметрами. 
 array_map(имя функции в кавычках, массив, [еще массивы через запятую]);-->

 <!-- Давайте извлечем квадратный корень из каждого элемента массива (с помощью функции sqrt) и запишем в новый массив:-->

<!-- <?php
	$arr = [1, 4, 9];
	$result = array_map('sqrt', $arr);
	print_r($result);
?>  -->
<!-- Результат выполнения кода:
[1, 2, 3] -->

<!-- Создайте новый массив, в котором будут лежать квадратные корни данных элементов. -->
<!-- <?php
	$arr = [1, 2, 3, 4, 5];
	$result = array_map('sqrt', $arr);
	print_r($result);
?> -->

<!-- Функция array_intersect вычисляет пересечение массивов - возвращает массив из элементов,
 которые есть во всех массивах, переданных в функцию. 
 array_intersect(массив, массив, массив...);
 -->

 <!-- Давайте найдем, какие элементы есть и в одном, и в другом массиве (это 3, 4, 5): -->
<!-- <?php
	$arr1 = [1, 2, 3, 4, 5];
	$arr2 = [3, 4, 5, 6, 7];
	
	$result = array_intersect($arr1, $arr2);
	print_r($result);
?> -->
<!-- Результат выполнения кода:
[3, 4, 5] -->

<!-- array array_diff ( array $array1 , array $array2 [, array $... ] )
Сравнивает array1 с одним или несколькими другими массивами и возвращает значения из array1, 
которые отсутствуют во всех других массивах. -->

<!-- Пример использования array_diff() -->
<!-- <?php
$array1 = array("a" => "green", "red", "blue", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_diff($array1, $array2);
print_r($result);
?> -->

<!-- Дан массивы: Запишите в новый массив элементы, которые есть и в том, и в другом массиве. -->
<!-- <?php
	$arr1 = [1, 2, 3, 4, 5];
	$arr2 = [3, 4, 5, 6, 7];
	$result1 = array_intersect ($arr1, $arr2);
	$result2 = array_intersect ($arr2, $arr1);
	$arr3 = $result1 + $result2;
	print_r($arr3);
?> -->

<!-- Запишите в новый массив элементы, которые не присутствуют в обоих массивах одновременно. -->
<!-- <?php
	$arr1 = [1, 2, 3, 4, 5];
	$arr2 = [3, 4, 5, 6, 7];
	$result1 = array_diff($arr1, $arr2);
	$result2 = array_diff($arr2, $arr1);
	$arr3 = $result1 + $result2;
	print_r($arr3);
?> -->
<!-- 162 Функции для времени-даты в PHP
Работа с timestamp -->

<!-- Функция time возвращает текущий момент времени в формате timestamp. Формат timestamp - это количество секунд, 
прошедшее с 1-го января 1970 года по заданный момент времени. -->

<!-- Давайте выведем разницу в секундах между 1-го января 1970 года и текущим моментом времени: -->
<!-- <?php
	echo time();
?> -->

<!-- Функция mktime переводит заданную дату в формат timestamp. 
Формат timestamp - это количество секунд, прошедшее с 1-го января 1970 года по заданный момент времени.
mktime(часы, минуты, секунды, месяц, день, год); -->

<!-- Давайте получим разницу в секундах между 1970 годом и 31.12.2025, 12:59:59: -->
<!-- <?php
	echo mktime(12, 59, 59, 12, 31, 2025);
?> -->

<!-- Выведите 1 марта 2025 года в формате timestamp. 
 Выведите 31 декабря текущего года в формате timestamp. 
 Скрипт должен работать независимо от года, в котором он запущен.
 Найдите количество секунд, прошедших с 13:12:59 15-го марта 2000 года до настоящего момента времени
-->
<!-- <?php
$year1 = date('Y');
$year = mktime(0,0,0,12,31, $year1);
	echo $year . '<br>';
$today = time();
$onse_date = mktime(13,12,59,03,15,2000);
	echo $today - $onse_date;
	?>  -->
 <!-- Найдите количество целых часов, прошедших с 7:23:48 текущего дня до настоящего момента времени. -->
<!-- <?php
$now_date = time();
$now_Y = date('Y', $now_date);
$now_m = date('m', $now_date);
$now_d = date('d', $now_date);
$time_1 = mktime(7, 23, 48, $now_m, $now_d, $now_Y);
$time_2 = $now_date - $time_1;
echo date('h', $time_2);
?> -->
<!-- 
Выведите на экран текущий год, месяц, день, час, минуту, секунду -->
<!-- <?php
echo date( 'Y-m-d-h-i-s', time());
?> -->

<!-- Выведите текущую дату-время в форматах 2025-12-31, 31.12.2025, 31.12.13, 12:59:59 -->
<!-- <?php
echo date( 'Y-m-d', time()) . '<br>';
echo date( 'd.m.Y', time()) . '<br>';
echo date( 'd.m.y', time()) . '<br>';
echo date( 'h:i:s', time()) . '<br>';
?> -->

<!-- С помощью функций mktime и date выведите 12 февраля 2025 года в формате 12.02.2025. -->
<!-- <?php
 echo date('d.m.Y', mktime(0, 0, 0, 02, 12, 2025));
 ?> -->

<!-- Создайте массив дней недели. С помощью этого массива и функции date выведите на экран название текущего дня недели. 
Узнайте какой день недели был 06.06.2006, в ваш день рождения. -->
<!-- <?php
$arr = ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'];
echo 'Текущий день недели - ' . $arr[ date('w', time()) ] . '<br>';
echo 'Текущий день недели 04.04.1987 - ' . $arr[ date('w', mktime(0, 0, 0, 4, 4, 1987)) ] . '<br>';
?> -->

<!-- Создайте массив месяцев. С помощью этого массива и функции date выведите на экран название текущего месяца. -->
<!-- <?php
 $arr_month = ['0', 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
 echo 'Текущий месяц - ' . $arr_month[ date('n', time()) ];
 ?> -->

<!-- Найдите количество дней в текущем месяце. Скрипт должен работать независимо от месяца, в котором он запущен. -->
<!-- <?php
 echo date('t', time());
 ?> -->

<!-- Дана дата в формате 2025-12-31. С помощью функции strtotime и функции date преобразуйте ее в формат 31-12-2025. -->
<!-- <?php
 echo date('d-m-Y', strtotime('2025-12-31'));
 ?> -->

<!-- В переменной $date лежит дата в формате 2025-12-31. 
 Прибавьте к этой дате 2 дня, 
 1 месяц и 
 3 дня, 
 1 год. 
 Отнимите от этой даты 3 дня. -->
<!-- <?php
 $date = '2025-12-31';
 $date_1 = date_create($date);
 $date_2 = date_create($date);
 $date_3 = date_create($date);
 $date_4 = date_create($date);
  
 date_modify($date_1, '2 day');
 date_modify($date_2, '3 day 1 month');
 date_modify($date_3, '1 year');
 date_modify($date_4, '-3 day');
  
 echo date_format($date_1, 'Y.m.d') . '<br>';
 echo date_format($date_2, 'Y.m.d') . '<br>';
 echo date_format($date_3, 'Y.m.d') . '<br>';
 echo date_format($date_4, 'Y.m.d') . '<br>';
 ?> -->

<!-- Узнайте сколько дней осталось до Нового Года. Скрипт должен работать в любом году -->
<!-- <?php
 $today = mktime(0, 0, 0, date( 'm', time() ), date( 'd', time() ), date( 'Y', time() ));
 /*
 $today = mktime(0,0,0,12,20,2022);*/
 $date = date('Y', $today);
 $date = date_create($date);
 date_modify($date, '1 year');
 $next_year = date_format($date, 'Y');
 $next = mktime(0, 0, 0, 01, 01, $next_year);
 $do_new_year = ($next - $today) / 3600 / 24;
 echo date('d-m-Y', $today) . '<br>';
 echo date('d-m-Y', $next) . '<br>';
 echo round($do_new_year) .  ' дней осталось до Нового Года';
 ?> -->

<!-- Пусть в переменной содержится некоторый год. Найдите все пятницы 13-е в этом году. Результат выведите в виде массива дат. -->
<!-- <?php
 $year = 2024;
 $friday_13  = [];
 $date = date_create( $year . '-01-13' );
 for ( $i=0; $i <= 11; $i++ ){
  if ( date_format($date, 'w') == 5 ){
  $friday_13[] = date_format($date, 'Y-m-d');
  }
  date_modify($date, '1 month');
 }
 echo 'Год: ' .$year . '<br>';
 print_r($friday_13);
 ?> -->

<!-- Узнайте какой день недели был 100 дней назад. -->
<!-- <?php
 $minus_days = 100;
 $now = date('Y-m-d', time());
 $date = date_create($now);
 date_modify($date, '-' . $minus_days . ' day');
 echo date_format($date, 'Y-m-d');
 ?> -->

<!-- time() — Возвращает текущий момент времени в формате timestamp. 
Формат timestamp — это количество секунд, прошедшее с 1-го января 1970 года по заданный момент времени.

mktime() — Переводит заданную дату в формат timestamp.

date() — Выводит дату в заданном формате. 1-м параметром функция принимает формат, 
а 2-м необязательным параметром — момент времени в формате timestamp. 
Если 2-й параметр не указан — возратится текущий момент времени, если указан — то заданный.
U – количество секунд, прошедших с 1 января 1970 года (то есть timestamp).
z – номер дня от начала года.
Y – год, 4 цифры.
y - год, две цифры.
m – номер месяца (с нулем спереди).
n – номер месяца без нуля впереди.
d – номер дня в месяце, всегда две цифры (то есть первая может быть нулем).
j – номер дня в месяце без предваряющего нуля.
w – день недели (0 - воскресенье, 1 - понедельник и т.д.).
h – часы в 12-часовом формате.
H – часы в 24-часовом формате.
i – минуты.
s – секунды.
L – 1, если високосный год, 0, если не високосный.
W – порядковый номер недели года.
t – количество дней в указанном месяце.

strtotime() — преобразует произвольную дату в формат timestamp. Форматы аргумента: ‘2024-11-30′, ’11 September 2004’, ‘Tomorrow’.

date_create() — создает объект ‘дата’, с которым далее можно выполнять 
некоторые операции функциями date_modify() (прибавить или отнять промежуток от даты) и date_format() (вывести дату в другом формате).

date_modify() — позволяет прибавлять и отнимать от даты определенные промежутки времени.
 При этом дата должна быть объектом, созданным функцией date_create. 
 Функция изменяет и возвращает сам переданный объект ‘дата’.

date_format() — выводит данные из объекта ‘дата’ в определенном формате. 
При этом дата должна быть объектом, созданным функцией date_create. 
Управляющие команды для формата аналогичны, как в функции date. -->

<!-- Примеры работы с date -->
<!-- <?php
	
	echo date('Y').'<br>'; // выведет '2024'
	echo date('y').'<br>'; // выведет '24'
	echo date('m').'<br>'; // выведет '08' - номер месяца
	echo date('d').'<br>'; // выведет '04' - номер дня в месяце
	echo date('j').'<br>'; // выведет '4'  - номер дня в месяце (без нуля спереди)
	echo date('w').'<br>'; // выведет '0'  - вскресенье
	echo date('H').'<br>'; // выведет '20' - часы
	echo date('i').'<br>'; // выведет '01' - минуты
	echo date('s').'<br>'; // выведет '29' - секунды
	
	echo date('d-m-Y').'<br>'; // выведет '04-08-2024'
	echo date('d.m.Y').'<br>'; // выведет '04.08.2024'
	echo date('H:i:s d.m.Y').'<br>'; // выведет '20:01:29 04.08.2024'
	?> -->


<!-- <?php
// Создайте массив месяцев. 
// С помощью этого массива и функции date выведите на экран название текущего месяца.
$arr = ['0', 'янв', 'фев', 'март', 'апр','май','июнь','июль','авг','сент','окт','нояб', 'дек'];
$now = time();
echo $arr[date('n', $now)];
?> -->

<!-- Найдите количество дней в текущем месяце.
 Скрипт должен работать независимо от месяца, в котором он запущен. -->
 <!-- <?php
 echo date('t', time());
 ?> -->

<!-- Функция strtotime
Функция strtotime преобразует произвольную дату в формат timestamp. Формат timestamp - это количество секунд, 
прошедшее с 1-го января 1970 года по заданный момент времени. -->

<!-- Дана дата в формате 2025-12-31. С помощью функции strtotime и
 функции date преобразуйте ее в формат 31-12-2025. -->
 <!-- <?php
 echo date('d-m-Y', strtotime('2025-12-31'));
 ?> -->

<!-- Функция date_create создает объект 'дата', с которым в дальнейшем можно выполнять некоторые операции. 
К примеру, прибавить или отнять промежуток от даты с помощью date_modify 
или вывести дату в другом формате с помощью функции date_format. -->

<!-- Давайте создадим объект с датой за 2025 год, 12 месяц, 31 день, 
затем прибавим к ней 1 день и выведем в формате 'день.месяц.год': -->
<!-- <?php
	$date = date_create('2025-12-31');
	date_modify($date, '1 day');
	echo date_format($date, 'd.m.Y');
?> -->

<!-- Функция date_modify позволяет прибавлять и отнимать от даты определенные промежутки времени. 
Дата при этом должна быть объектом, созданным функцией date_create.
 Функция изменяет сам переданный объект, и возвращает также измененный объект 'дата'. -->

 <!-- Давайте создадим объект с датой за 2025 год, 12 месяц, 31 день, 
 затем прибавим к ней 3 дня и 1 месяц и выведем в формате 'день.месяц.год': -->
<!-- <?php
	$date = date_create('2025-12-31');
	date_modify($date, '3 days 1 month');
	echo date_format($date, 'd.m.Y');
?> -->

<!-- Функция date_format выводит данные из объекта 'дата' в определенном формате. 
Дата при этом должна быть объектом, созданным функцией date_create. 
Управляющие команды для формата такие же, как в функции date. -->

<!-- Давайте создадим объект с датой за 2025 год, 12 месяц, 31 день, 
затем прибавим к ней 1 день и выведем в формате 'день.месяц.год': -->
<!-- <?php
	$date = date_create('2025-12-31');
	date_modify($date, '1 day');
	echo date_format($date, 'd.m.Y');
?> -->

<!-- В переменной $date лежит дата в формате 2025-12-31.
 Прибавьте к этой дате 2 дня, 1 месяц и 3 дня, 1 год. Отнимите от этой даты 3 дня. -->
 <!-- <?php
 $date = date_create('2025-12-31');
 date_modify($date, '1 year');
 date_modify($date, '-3 day');
 echo date_format($date, 'd/m/Y');
 ?> -->

<!-- Узнайте сколько дней осталось до моего день рождения . Скрипт должен работать в любом году. -->
<!-- 
<?php
$today = mktime(0,0,0, date('m', time()), date('d', time()), date('Y', time()));
$date = date('Y', $today);
$date = date_create($date);
date_modify($date, '1 year');
$next_year = date_format($date, 'Y');
$next = mktime(0,0,0,04,04, $next_year);
$do_new_year = ($next - $today)/3600/24;
echo $do_new_year;
?> -->

<!-- Пусть в переменной содержится некоторый год. 
Найдите все вторники 5-е в этом году. Результат выведите в виде массива дат. -->
 <!-- <?php
 $year = 2024;
 $tuesday_05 = [];
 $date = date_create($year. '-01-05');
 for($i=0; $i <=11; $i++){
	if(date_format($date, 'w')==2){
		$tuesday_05[] = date_format($date, 'Y-m-d');
	}
	date_modify($date, '1 month');
 }
 echo $year. '<br>';
 print_r($tuesday_05);
 ?> -->

<!-- Узнайте какой день недели был 90 дней назад. -->
<!-- <?php
$minus_days = 90;
$now = date('Y-m-d', time());
$date = date_create($now);
date_modify($date, '-'.$minus_days. ' day');
$date = date_format($date, 'd,m,Y');
echo $date.'<br>';
echo date('w', mktime(0,0,0,$date));
?> -->
<!-- 163 Практика на использования изученных функций PHP
В следующих задачах вы должны применить комбинацию стандартных функций PHP, 
чтобы решить задачу. Циклы использовать запрещено. -->

<!-- Дан массив с числами. Найдите среднее арифметическое его элементов. -->
<!-- <?php
$arr = [5,7,10,5,22,44];
$length = count($arr);
echo array_sum($arr)/$length;
?> -->

<!-- Найдите сумму чисел от 1 до 100. -->
 <!-- <?php
 $arr = range(1, 100);
 $result = array_sum($arr);
 echo $result;
 ?> -->

<!-- Выведите столбец чисел от 1 до 100. -->
 <!-- <?php
$arr = range(1,100);
foreach($arr as $number){
    echo "$number ";
    if($number % 10 == 0)
        echo '<br />';  
}
  ?> -->
<!-- <?php
$arr = range(1,10);
foreach($arr as $number){
  echo 'x';
} ?>-->

<!-- Заполните массив 10-ю случайными числами от 1 до 10 так, чтобы они не повторялись. -->
<!-- <?php
$arr = range(1,10);
shuffle($arr);
echo'<pre>';
print_r($arr);
echo'</pre>';
?> -->

<!-- Найдите факториал заданного числа. -->
<!-- <?php
$num = 10;
$res = 1;
for($i=1; $i<=$num; $i++){
  $res*=$i;
}
echo $res;
?> -->

<!-- Дано число. Найдите сумму цифр этого числа. Для этого разобьем число в массив с помощью str_split 
и сложим элементы этого массива с помощью array_sum:-->
 <!-- <?php
 $num = 25;
 echo array_sum(str_split($num,1));
 ?> -->

<!-- Дана строка. Сделайте заглавным последний символ этой строки - это Строковые функции PHP-->
<!-- <?php
$str = 'Fregat';
echo strrev(ucfirst(strrev($str)));
?> -->

<!-- Дан массив с числами. Получите из него массив с квадратными корнями этих чисел -->
 <!-- <?php
 $arr = [2,8,16,32,64,128];
 $length = count($arr);
 for($i=0; $i<$length;$i++){
  $arr[$i] = $arr[$i]*$arr[$i];
 }
 print_r($arr);
 ?> -->
 <!-- не используя цикл -->
<!-- <?php
$arr = [2,8,16,32,64,128];
$result = array_map('sqrt', $arr);
echo '<pre>';
print_r($result);
echo '</pre>';
?> -->

<!-- Заполните массив числами от 1 до 26 так, чтобы ключами этих чисел были буквы английского алфавита:
 -->
<!-- <?php
$arr1 = range(1, 26);
$arr2 = range('a', 'z');
$result = array_combine($arr2, $arr1);
echo'<pre>';
print_r($result);
echo'</pre>';
?> -->

<!-- Дана строка '1234567890'. Найдите сумму цифр из этой строки. -->
 <!-- <?php
 $str = '1234567890';
 $arr = str_split($str,1);
 $res = array_sum($arr);
echo $res;
?> -->

<!-- Дана некоторая строка с числами, например, такая:
Найдите сумму пар чисел: -->
<!-- <?php
	$str = '1234567890';
  $arr = str_split($str, 2);
  $res = array_sum($arr);
  echo $res;
?> -->

<!-- Используя комбинацию функций заполните массив следующим образом: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] -->
<!-- <?php
$str = '123456789';
$arr = str_split($str, 1);
$res = array_chunk($arr,3);
echo'<pre>';
print_r($res);
echo'</pre>';
?> -->

<!-- 164 Основы работы с пользовательскими функциями в PHP
Сейчас мы научимся создавать свои функции, 
которые затем можно будет использовать подобно стандартным функциям PHP.
Давайте рассмотрим синтаксис для создания своей функции.
Функция создается с помощью команды function. 
Далее через пробел следует имя функции и круглые скобки, в которых пишется какой-то код: -->
<!-- 
Давайте теперь вызовем нашу функцию. Для этого необходимо написать ее имя и круглые скобки: -->
<!-- <?php
	//function func() {
		//echo '!';
	//}
	// Вызываем нашу функцию:
	//func(); // выведет '!'
?> -->

<!-- Функции могут быть вызваны до места своего определения: -->


<!-- Сделайте функцию, выводящую на экран сумму чисел от 1 до 100. -->
 <!-- <?php
 sum();
 function sum() {
    $arr = range(1, 100);
    $result = array_sum($arr);
    echo $result;
 }
 ?> -->
 
 <!-- 165 Параметры функций в PHP -->

 <!-- Давайте теперь сделаем так, чтобы наша функция выводила квадрат переданного числа. 
 Для этого перемножим переменную $num саму на себя и выведем на экран: -->
 <!-- <?php
	// function func($num) {
	// 	echo $num * $num;
	// }
	
	// func(2); // выведет 4
	// func(3); // выведет 9
?> -->

<!-- Сделайте функцию, которая параметром принимает число и проверяет, положительное это число или отрицательное. 
В первом случае пусть функция выводит на экран текст '+++', а во втором '---' -->
<!-- <?php
// function func($num){
//     if ($num >= 0){
//         echo '+++';
//     }else
//     echo '---';
// }
// func(0);
?> -->

<!-- 166 Несколько параметров функций в PHP -->

<!-- Функция может принимать не один параметр, а несколько. В этом случае их нужно перечислить через запятую. -->
<!-- Сделайте функцию, которая параметрами принимает 3 числа и выводит на экран сумму этих чисел. -->
<!-- <?php
	// function func($num1, $num2, $num3) {
	// 	echo $num1 + $num2 + $num3;
	// }
	
	// func(1, 2, 3); // выведет 3
?> -->
<!-- 
167 Параметры-переменные функций в PHP -->

<!-- Не обязательно параметром функции передавать именно число - можно передать и переменную, содержащую нужное нам число: -->
<!-- <?php
	// function func($num) {
	// 	echo $num * $num;
	// }
	
	// $param = 2;
	// func($param);
?> -->

<!-- Сделайте функцию func, которая параметром будет принимать 3 числа и выводить на экран их сумму. 
С помощью этой функции выведите на экран сумму значений следующих переменных: -->
<!-- <?php
// $param1 = 1;
// $param2 = 2;
// $param3 = 3;
// function func($num1,$num2,$num3){
//     echo $num1 + $num2 + $num3;
// }
//     func($param1, $param2, $param3);
?> -->

<!-- 168 Необязательные параметры функций в PHP -->
<!-- 
Параметры функций можно делать не обязательными. Для этого параметрам нужно задать значения по умолчанию
Давайте сделаем так, чтобы этот параметр по умолчанию имел значение 0: -->
<!-- <?php
	// function func($num = 0) {
	// 	echo $num ** 2;
	// }
    // func(2);
    // func();
?> -->

<!-- 169 Инструкция return в PHP -->

<!-- Пусть мы хотим не выводить значение на экран, а записать в какую-нибудь переменную, вот так: -->
	<!-- $res = func(3); // в переменной $res теперь 9
Для этого в PHP существует специальная инструкция return, которая позволяет указать значение, которое возвращает функция. 
Под словом возвращает понимают то значение, которое запишется в переменную, если ей присвоить вызванную функцию. -->

<!-- Итак, давайте перепишем нашу функцию так, чтобы она не выводила результат на экран, а возвращала его в переменную: -->
<!-- <?php
	// function func($num) {
	// 	return $num * $num;
	// }
	// $res = func(3);
	// echo $res; // выведет 9
    // $res = func(2) + func(3);
	// echo $res; // выведет 13
?> -->

<!-- Сделайте функцию, которая параметром принимает число, а возвращает куб этого числа. 
С помощью этой функции найдите куб числа 3 и запишите его в переменную $res.
С помощью созданной вами функции найдите сумму кубов числа 2 и числа 3 и запишите ее в переменную $res. -->
<!-- <?php
// function func($num){
//     return $num*$num*$num;
// }
// $res = func(3) + func(2);
// echo $res;
?> -->
<!-- 170 Последовательный вызов функций в PHP -->

<!-- Можно результат работы одной функции передать параметром в другую. 
В следующем примере мы сначала найдем квадрат числа 2, а затем квадрат результата: -->
<!-- <?php
	function func1($num) {
		return $num * $num;
	}
	
	$res = func1(func1(2));
	echo $res; // выведет 16
?> -->

<!-- Пусть теперь у нас есть функция, возвращающая квадрат числа, и функция, находящая сумму двух чисел:
Найдем с помощью этих функций сумму квадрата числа 2 и сумму квадрата числа 3: -->
<!-- <?php
	function square($num) {
		return $num * $num;
	}
	function sum($num1, $num2) {
		return $num1 + $num2;
	}
	$res = sum(square(2), square(3));
	echo $res;
?> -->

<!-- 171 Тонкое место return в PHP -->

<!-- Это не значит, что в функции должен быть один return. Но выполнится только один из них.
В следующем примере в зависимости от значения параметра выполнится либо первый, либо второй return: -->
<!-- <?php
	function func2($num) {
		if ($num >= 0) {
			return '+';
		} else {
			return '-';
		}
	}
	echo func2( 3); // выведет '+'
	echo func2(-3); // выведет '-'
?> -->
<!-- 
Что выведется на экран в результате выполнения следующего кода: -->
<!-- <?php
	function func3($num) {
		return $num;//выведется 3
		
		$res = $num * $num;
		return $res;
	}
	
	echo func3(3);
?> -->

<!-- Что выведет каждый из echo в результате выполнения следующего кода: -->
<!-- <?php
	function func4($num) {
		if ($num <= 0) {
			return abs($num);//модуль разности
		}
		return $num * $num;
	}
	echo func4(10).'<br>';
	echo func4(-5);
?> -->

<!-- 172 Цикл и return в PHP -->

<!-- Пусть у нас есть функция, возвращающая сумму чисел от 1 до 5: -->
<!-- <?php
	function func5() {
		$sum = 0;
		for ($i = 1; $i <= 5; $i++) {
			$sum += $i;
		}
		return $sum;
	}
	$res = func5();
	echo $res; // выведет 15
?> -->

<!-- Пусть теперь мы расположим return внутри цикла, вот так:
В этом случае цикл прокрутится лишь одну итерацию и произойдет автоматический выход из функции (ну и заодно из цикла). 
А за одну итерацию цикла в переменной $sum окажется лишь число 1, а не вся нужная сумма. -->
<!-- <?php
	function func6() {
		$sum = 0;
		
		for ($i = 1; $i <= 5; $i++) {
			$sum += $i;
			return $sum;
		}
	}
	$res = func6();
	echo $res;
?> -->

<!-- 173 Применение return в цикле в PHP -->

<!-- То, что return расположен внутри цикла, не всегда может быть ошибкой.
В следующем примере сделана функция, которая определяет, сколько первых элементов массива нужно сложить, 
чтобы сумма стала больше или равна 10: -->
<!-- <?php
	function func7($arr) {
		$length = count($arr);
		$sum = 0;
		for ($i = 0; $i < $length; $i++) {
			$sum += $arr[$i];
			
			// Если сумма больше или равна 10:
			if ($sum >= 10) {
				return $i + 1; // выходим из цикла и из функции
			}
		}
	}
	
	$res = func7([1, 2, 3, 1, 4, 5]);
	echo $res;
?> -->

<!-- А в следующем примере сделана функция, которая вычисляет, сколько целых чисел, начиная с 1, 
нужно сложить, чтобы результат был больше 100: -->
<!-- <?php
	function func8() {
		$sum = 0;
		$i = 1;
		while (true) { // бесконечный цикл
			$sum += $i;
			if ($sum >= 100) {
				return $i; // цикл крутится пока не выйдет тут
			}
			$i++;
		}
	}
	echo func8();
?> -->

<!-- Напишите функцию, которая параметром будет принимать число и делить его на 2 столько раз, пока результат не станет меньше 10.
 Пусть функция возвращает количество итераций, которое потребовалось для достижения результата -->
 <!-- <?php
 function func9($num){
    $i = 1;
    while(true){
        $num = $num/2;
        if($num<=10){
            return $i;
        }
        $i++;
    } 
 }
 echo func9(40);
 ?> -->

<!-- 174 Приемы работы с return в PHP -->
<!-- 
Существуют некоторые приемы работы с return, упрощающие код.
Рассмотрим, к примеру, следующий код: -->
<!-- <?php
	function func10($num) {
		if ($num >= 0) {
			$res = sqrt($num);
		} else {
			$res = 0;
		}
		return $res;
	}
	echo func10(3);
?> -->

<!-- Как вы видите, в данном коде в зависимости от условия в переменную $res будет попадать либо одно, либо другое значение. 
А последней строкой функции содержимое этой переменной возвращается через return.
Давайте перепишем этот код в более сокращенной форме, избавившись от ненужной здесь переменной $res: -->
<!-- <?php
	function func11($num) {
		if ($num >= 0) {
			return sqrt($num);
		} else {
			return 0;
		}
	}
	echo func11(3);
?> -->
<!-- 
Дана следующая функция:
Перепишите ее в сокращенной форме согласно изученной теории. -->
<!-- <?php
	// function func($num1, $num2) {
	// 	if ($num1 > 0 and $num2 > 0) {
	// 		$res = $num1 * $num2;
	// 	} else {
	// 		$res = $num1 - $num2;
	// 	}
	// 	return $res;
	// }
	// echo func(3, 4);
?> -->
<!-- <?php
	function func12($num1, $num2) {
		if ($num1 > 0 and $num2 > 0) {
			return $num1 * $num2;
		} else{
		return $num1 - $num2;
    }
    }
	echo func12(3, 4);
?> -->

<!-- 175 Флаги в функциях PHP -->
<!--  
В функциях можно использовать флаги в неявном виде с помощью инструкции return. Давайте посмотрим, как это делается. 
Пусть у нас есть следующая функция, проверяющая, что все элементы массива положительные числа: -->
<!-- <?php
	function isPositive($arr) {
		$flag = true;
		foreach ($arr as $elem) {
			if ($elem < 0) {
				$flag = false;
			}
		}
		return $flag;
	}
?> -->

<!-- Давайте перепишем код функции с помощью неявного использования флагов:
Как это работает: если в массиве найдется нужный элемент - мы выйдем из функции (и из цикла тоже) с помощью return. 
Но если в массиве не найдется нужный элемент - выхода из функции не произойдет и выполнение дойдет до команды return true. 
И получится, что функция вернет true в знак того, что в массиве все элементы положительные. -->
<!-- <?php
	function isPositive1($arr) {
		foreach ($arr as $elem) {
			if ($elem < 0) {
				return false;
			}
		}
		return true;
	}
   var_dump (isPositive1([1,2,3,4,5]));
?> -->

<!-- Сделайте функцию, которая параметром будет принимать массив и проверять, есть ли в этом массиве два одинаковых элемента подряд. -->
 <!-- <?php
 function equel($arr){
    $length = count($arr);
 for ($i=0; $i< $length; $i++){
    if($arr[$i] === $arr[$i + 1]){
        return true;
    }
 }
 return false;
 }
var_dump(equel([1,2,3,4,4,5]));
 ?> -->

 <!-- 176 Логические операторы без if в функциях PHP -->

<!-- <?php
	// function func($a, $b) {
	// 	if ($a > $b) {
	// 		return true;
	// 	} else {
	// 		return false;
	// 	}
	// }
?> -->
<!-- Как вы уже знаете из предыдущих уроков, конструкции if, возвращающие булевы значения, 
можно переписывать в сокращенной форме.
Давайте сделаем это: -->
<!-- <?php
	function func($a, $b) {
		return $a > $b;
	}
    var_dump (func(1, 2));
?> -->

<!-- <?php
	function func1($a, $b) {
	return $a===$b;
	}
?> -->

<!-- 177 Советы по созданию функций в PHP -->
<!-- 
Имена функций должны быть глаголами.
Имя каждой функции должно точно отражать то, что функция делает.
Функция должна делать только то, что явно подразумевается её названием, и не делать другого.
Каждая функция должна выполнять только одно действие.
Используйте внутри функций вспомогательные функции.
Код функций лучше не делать длиннее 10-15 строк.
Длинные функции лучше разбивать на ряд вспомогательных.
Используйте общепринятые префиксы в именах функций: show, get, set, calc, create, change, check.
Выносите дублирующийся код в функции. -->
<!-- 
Напишите, какие недостатки у следующего кода, и исправьте их: -->
<!-- <?php
	function calc($arr) {
		$res = 0;
		
		foreach ($arr as $elem) {
			$res += $elem;
		}
		
		return $res / count($arr);
	}
?> -->


<!-- Напишите, какие недостатки у следующего кода, и исправьте их: -->
<!-- <?php
	function func2($arr1, $arr2) {
		$res1 = 0;
		
		foreach (arr1 as $elem1) {
			$res1 += $elem;
		}
		
		$res2 = 0;
		
		foreach (arr2 as $elem2) {
			$res2 += $elem;
		}
		return $res1 / $res2;
	}
?> -->

<!-- Напишите, какие недостатки у следующего кода, и исправьте их: -->
<!-- <?php
	function getSum($arr) {
		$res = 0;
		
		foreach ($arr as $elem) {
			$res *= $elem;
		}
		
		return $res;
	}
?> -->

<!-- 178 Практика на функции PHP -->
<!-- 
Сделайте функцию, которая параметром будет принимать число и возвращать массив его делителей. -->
 <!-- <?php
function calc1($num){
    $arr = [];
    for($i = 1; $i*$i < $num; $i++){
        if($num % $i == 0){
            array_push($arr, $i, $num/$i);
        }
    }
    if($i*$i==$num){
        array_push($arr, $i);
    }
    return $arr;
}
print_r(calc1(200));
?>  -->


<!-- Сделайте функцию, которая параметром будет принимать два числа и возвращать массив их общих делителей. -->
 <!-- <?php
 function calc2($a, $b){
	$arr1 = [];
	$arr2 = [];
	for($i=1; $i*$i < $a, $i*$i < $b; $i++){
		if($a %$i ==0){
			array_push($arr1, $i, $a/$i);
		}
		if($b %$i ==0){
			array_push($arr2, $i, $b/$i);
		}
		
	}
	return array_intersect($arr1, $arr2);

 }

 print_r(calc2(22,44));
 ?> -->

<!-- Сделайте функцию, которая параметром будет принимать число и возвращать сумму его цифр. -->
 <!-- <?php
 function sum1($num){
	$arr = array_map('intval', str_split($num));
	foreach($arr as $elem){
		$res += +$elem;
	}
	return $res;
 }
 print_r(sum1(1234));
 ?> -->

<!-- <?php
 function sum2($num){
	return array_sum(str_split($num, 1));
 }
 print_r(sum2(12345));
 ?> -->

<!-- Сделайте функцию, которая вернет текущий день недели словом. 
 Сделайте функцию, которая параметром будет получать дату, а возвращать день недели словом, соответствующий этой дате.-->
<!-- <?php
function find($day){
	$arr = ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'];
	//return $arr[date('w', time())];
	return $arr[date('w', $day)];
}
//echo find(time()).'<br>';
echo find(mktime(0, 0, 0, 9, 9, 2024));
?> -->

<!-- Сделайте функцию, которая параметром будет принимать секунды, а возвращать количество суток, соответствующих этим секундам. -->
 <!-- <?php
 function calcsec($n){
	return $n/86400;
 }
echo calcsec(111111);
?> -->

<!-- Сделайте функцию, которая параметром будет год и проверять, високосный он или нет. -->
 <!-- <?php
 function checkY($y){
	  // Получаем количество дней в феврале заданного года 
	  $days = date("t", strtotime("$y-02-01")); 
	  // Если дней 29, то год високосный 
	  return $days == 29; 
 }
 echo checkY(2028);
 ?> -->

<!-- Сделайте функцию, которая параметром будет принимать число и проверять, простое оно или нет. -->
 <!-- <?php 
function is_prime($number) {
	if($number == 1) {
	  return false;
	}
	for($i = 2; $i <= sqrt($number); $i++) {
	  if($number % $i == 0) {
		return false;
	  }
	}
	return true;
}
var_dump(is_prime(5));
?> -->
<!-- 179 Работа с рекурсией в PHP -->

<!-- В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя. 
Давайте посмотрим на примере. Выведем с помощью рекурсии числа от 1 до 10: -->

<!-- 180 Рекурсия с параметром в PHP -->

<!-- Давайте пока без рекурсии используя функцию array_shift выведем все элементы массива по очереди: -->
<!-- <?php
   function func1($arr) {
	   var_dump(array_shift($arr)); // выведет 1
	   var_dump($arr); // выведет [2, 3] - массив уменьшился
	   
	   var_dump(array_shift($arr)); // выведет 2
	   var_dump($arr); // выведет [3] - массив уменьшился
	   
	   var_dump(array_shift($arr)); // выведет 3
	   var_dump($arr); // выведет [] - массив пуст
   }
   func1([1, 2, 3]);
?> -->

<!-- Давайте теперь используем рекурсию: -->
<!-- <?php
   function func2($arr) {
	   var_dump(array_shift($arr));
	   var_dump($arr);
	   if (count($arr) !== 0) {
		   func2($arr);
	   }
   }
   func2([1, 2, 3]);
?> -->

<!-- Дан массив:
С помощью рекурсии выведите элементы этого массива на экран. -->
<!-- <?php
   
   function func3($arr){
	   foreach ($arr as $elem){
		   print_r(array_shift($arr));
		   print_r($arr);
	   }
	   
	   if (count($arr)!== 0){
		   func3($arr);
	   }
   }
   func3(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]);
?> -->

<!-- 181 Сумма элементов массива при рекурсии в PHP -->

<!-- Давайте теперь не будем выводить элементы массива на экран, а найдем сумму элементов этого массива: -->
<!-- <?php
   function getSum($arr) {
	   $sum = array_shift($arr);
	   if (count($arr) !== 0) {
		   $sum += getSum($arr);
	   }
	   return $sum;
   }
   var_dump(getSum([1, 2, 3]));
?> -->

<!-- С помощью рекурсии найдите сумму элементов этого массива. -->
<!-- <?php
function getsum2($arr){
   $sum = array_shift($arr);
   if(count($arr) !== 0){
	   $sum += getsum2($arr);
   }
   return $sum;
}

   print_r(getsum2(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]));
?> -->

<!-- 182 Рекурсия и многомерные структуры в PHP -->

<!-- Если данный массив имеет сложную структуру. 
Пусть мы хотим вывести на экран все примитивные (то есть не массивы) элементы нашего массива
Для перебора такого массива очень удобно будет использовать рекурсию. -->

<!-- сделаем так, чтобы если наш элемент - массив, функция вызывала сама себя, передавая параметром этот массив: -->
<!-- <?php
   function func4($arr) {
	   foreach ($arr as $elem) {
		   if (is_array($elem)) {
			   func4($elem);
		   } else {
			   echo $elem;
		   }
	   }
   }
   func4([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);
   ?> -->

<!-- Дан многомерный массив произвольного уровня вложенности, например, такой:
С помощью рекурсии выведите все примитивные элементы этого массива на экран. -->
<!-- <?php
function func5($arr){
   foreach ($arr as $elem){
	   if(is_array($elem)){
		   func5($elem);
	   }else{
		   echo $elem;
	   }
   }
}
func5([1, 2, 3, [4, 5, [6, 7]], [8, [9, 10]]])
?> -->

<!-- 183 Сумма элементов массива в PHP -->

<!-- Давайте найдем сумму примитивных элементов нашего массива: -->
<!-- <?php
   function func6($arr) {
	   $sum = 0;
	   foreach ($arr as $elem) {
		   if (is_array($elem)) {
			   $sum += func6($elem);
		   } else {
			   $sum += $elem;
		   }
	   }
	   
	   return $sum;
   }
   print_r(func6([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]));
?> -->

<!-- Дан многомерный массив произвольного уровня вложенности, например, такой:
С помощью рекурсии найдите сумму элементов этого массива. -->
<!-- <?php
function func7($arr){
   $sum = 0;
   foreach($arr as $elem){
	   if(is_array($elem)){
		   $sum += func7($elem);
	   }else{
		   $sum += $elem;
	   }
   }
   return $sum;
}
print_r(func7([1, 2, 3, [4, 5, [6, 7]], [8, [9, 10]]]));
?> -->

<!-- Дан многомерный массив произвольного уровня вложенности, содержащий внутри себя строки, например, такой:
С помощью рекурсии слейте элементы этого массива в одну строку: 'abcdefgjk' -->
<!-- <?php
   function func8($arr){
	   foreach($arr as $elem){
		   if(is_array($elem)){
			   $str .= func8($elem);
		   }else {
			   $str .= $elem;
		   }
	   }
	   return $str;
   }
   print_r(func8(['a', ['b', 'c', 'd'], ['e', 'f', ['g', ['j', 'k']]]]))
?> -->

<!-- 184 Манипуляции с элементами многомерного массива в PHP -->

<!-- Давайте что-нибудь сделаем с перебираемыми элементами массива, к примеру, запишем им в конец знак '!':
<?php
   function func9($arr) {
	   $length = count($arr);
	   
	   for ($i = 0; $i < $length; $i++) {
		   if (is_array($arr[$i])) {
			   $arr[$i] = func9($arr[$i]);
		   } else {
			   $arr[$i] = $arr[$i] . '!';
		   }
	   }
	   
	   return $arr;
   }
   echo '<pre>';
   print_r(func9([1, [2, 7, 8], [3, 4, [5, 6]]]));
   echo '</pre>';
?> -->

<!-- Дан многомерный массив произвольного уровня вложенности, например, такой:
Возведите все элементы-числа этого массива в квадрат. -->
<!-- <?php
function func10($arr){
   $length = count($arr);
   for($i = 0; $i < $length; $i++){
   if(is_array($arr[$i])){
	   $arr[$i] = func10($arr[$i]);
   }
   else{
	   $arr[$i] = $arr[$i]*$arr[$i];
   }
}
return $arr;
}
echo '<pre>';
print_r(func10([1, [2, 7, 8], [3, 4, [5, 6]]]));
echo '</pre>';
?> -->
<!-- 185 Введение в регулярные выражения в PHP -->

<!-- Существует несколько функций PHP для работы с регулярными выражениями.
Мы начнем знакомится с ними на примере preg_replace.
Эта функция первым параметром принимает что менять, а вторым - на что менять, а третьим параметром - строку, в которой нужно заменять: -->
<!-- <?php
	//preg_replace(что_менять, на_что, строка);
?> -->
<!-- При этом первым параметром наша функция принимает не просто строку, а регулярное выражение,
представляющее собой строку с набором команд, расположенных внутри символов решетки #. Эти решетки называются ограничителями регулярных выражений.
После ограничителей можно писать модификаторы - команды, которые изменяют общие свойства регулярного выражения.
Сами регулярные выражения состоят из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются специальные символы.
Буквы и цифры обозначают сами себя. В следующем примере мы с помощью регулярного выражения заменим букву 'a' на '!': -->
<!-- <?php
	//preg_replace('#a#', '!', 'bab'); // вернет 'b!b'
?> -->

<!-- А вот точка является специальным символом и обозначает любой символ.
В следующем примере мы найдем строку по такому шаблону: буква 'x', затем любой символ, затем опять буква 'x': -->
<!-- <?php
	//preg_replace('#x.x#', '!', 'xax eee'); // вернет '! eee'
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb' по шаблону: буква 'a', любой символ, буква 'b'.
Напишите регулярку, которая найдет строки 'aeeb', 'adcb', 'axeb' по шаблону: буква 'a', два любых символа, буква 'b'.-->
<!-- <?php
	//$str = 'ahb acb aeb aeeb adcb axeb';
   // echo preg_replace('#a..b#', '?', $str)
?>  -->

<!-- 186 Операторы повторения символов в регулярках -->

<!-- Бывают ситуации, когда мы хотим указать, что символ повторяется заданное количество раз.
Если мы знаем точное число повторений, то можно просто написать его несколько раз - #aaaa#.
Но что делать, если мы хотим сказать такое: повторить один или более раз?
Для этого существуют операторы (квантификаторы) повторения: плюс + (один и более раз),
звездочка * (ноль или более раз) и вопрос ? (ноль или один раз).
Эти операторы действуют на тот символ, который стоит перед ними.
Давайте посмотрим на работу этих операторов на примерах. -->

<!-- Найдем все подстроки по шаблону буква 'x', буква 'a' один или более раз, буква 'x': -->
<!-- <?php
	$str = 'xx xax xaax xaaax xbx';
	$res = preg_replace('#xa+x#', '!', $str);
    echo $res;//'xx ! ! ! xbx'
?> -->

<!-- Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или более раз, буква 'x':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xx xax xaax xaaax xbx';
	$res = preg_replace('#xa*x#', '!', $str);
    echo $res;//! ! ! ! xbx
?> -->

<!--
Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или один раз, буква 'x':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xx xax xaax xbx';
	$res = preg_replace('#xa?x#', '!', $str);
    echo $res;//'! ! xaax xbx'
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один или более раз, буква 'a'.
Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' ноль или более раз, буква 'a'.
Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один раз или ниодного, буква 'a'.
Напишите регулярку, которая найдет строки 'aa', 'aba', 'abba', 'abbba', не захватив 'abca' и 'abea'. -->
<!-- <?php
	$str = 'aa aba abba abbba abca abea';
   // echo preg_replace('#ab+a#', '%', $str);
    //echo preg_replace('#ab*a#', '&', $str);
    //echo preg_replace('#ab?a#', '$', $str);
?> -->

<!-- 187 Группирующие скобки в регулярках PHP -->

<!-- группирующие скобки '(' и ')' - работают так: если что-то стоит в группирующих скобках и сразу после ')'
стоит оператор повторения - он подействует на все, что стоит внутри скобок.
В следующем примере шаблон поиска выглядит так: буква 'x',
далее строка 'ab' один или более раз, потом буква 'x':
В результате в переменную запишется следующее:-->
<!-- <?php
	$str = 'xabx xababx xaabbx';
	$res = preg_replace('#x(ab)+x#', '!', $str);
    echo $res
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: строка 'ab' повторяется 1 или более раз. -->
<!-- <?php
	$str = 'ab abab abab abababab abea';
    echo preg_replace('#(ab)+#', '!', $str);//! ! ! ! !ea
?> -->

<!-- 188 Экранировка спецсимволов в регулярках PHP -->

<!-- Предположим, что мы хотим сделать так, чтобы спецсимвол обозначал сам себя.
Для этого его нужно экранировать с помощью обратного слеша. Давайте посмотрим на примерах.
-->
<!-- А сейчас автор заэкранировал плюс обратным слешем. Теперь шаблон поиска выглядит так,
 как надо: буква 'a', затем плюс '+', затем буква 'x'.
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'a+x ax aax aaax';
	$res = preg_replace('#a\+x#', '!', $str);//'! ax aax aaax'
?> -->

<!-- 189 Список специальных символов в регулярках в PHP -->

<!-- Являются спецсимволами: $ ^ . * + ? \ / {} [] () |
Не являются спецсимволами: @ : , ' " ; - _ = < > % # ~ ` & ! -->

<!-- Дана строка:
Напишите регулярку, которая найдет строку 'a.a', не захватив остальные. -->
<!-- <?php
	$str = 'a.a aba aea';
	echo preg_replace('#a\.a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строку '2+3', не захватив остальные. -->
<!-- <?php
	$str = '2+3 223 2223';
	echo preg_replace('#2\+3#', '5', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки '2+3', '2++3', '2+++3', не захватив остальные (+ может быть любое количество). -->
 <!-- <?php
	$str = '23 2+3 2++3 2+++3 345 567';
	echo preg_replace('#2\++3#','%', $str);
?>  -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки '*q+', '*qq+', '*qqq+', не захватив остальные. -->
<!-- <?php
	$str = '*+ *q+ *qq+ *qqq+ *qqq qqq+';
	echo preg_replace('#\*q+\++#','?', $str);//*+ ? ? ? *qqq qqq+
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки в квадратных скобках и заменят их на '!'. -->
<!-- <?php
	$str = '[abc] {abc} abc (abc) [abc]';
	echo preg_replace('#\[abc\]#', '!', $str);
?> -->
<!--
190 Фигурные скобки в регулярных выражения PHP

Операторы +, *, ? хороши, однако, с их помощью нельзя указать конкретное число повторений.
В этом случае вам на помощь придет оператор {}.
Работает он следующим образом: {5} - пять повторений,
{2,5} - повторяется от двух до пяти (оба включительно),
{2,} - повторяется два и более раз. -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' один или два раза, буква 'x': -->
<!-- <?php
	$str = 'xx xax xaax xaaax';
	$res = preg_replace('#xa{1,2}x#', '!', $str);
	echo $res;
?> -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' два раза и более, буква 'x': -->
<!-- <?php
	$str = 'xx xax xaax xaaax';
	$res = preg_replace('#xa{2,}x#', '!', $str);
	echo $res;
?> -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' три раза, буква 'x': -->
<!-- <?php
	$str = 'xx xax xaax xaaax';
	$res = preg_replace('#xa{3}x#', '!', $str);
	echo $res;
?> -->

<!-- В данном примере шаблон поиска выглядит так: буква 'a' десять раз: -->
<!-- <?php
	$str = 'aaa aaaaaaaaaa aaa';
	$res = preg_replace('#a{10}#', '!', $str);
?> -->

<!-- Ноль тоже допустим: -->
<!-- <?php
	$str = 'xx xax xaax xaaax';
	$res = preg_replace('#xa{0,3}x#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки 'abba', 'abbba', 'abbbba' и только их.
Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается менее трех раз (включительно).
Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается более четырех раз (включительно).-->
<!-- <?php
	$str = 'aa aba abba abbba abbbba abbbbba';
	echo preg_replace('#ab{2,4}a#', '!', $str).'<br>';
	echo preg_replace('#ab{0,3}a#', '!', $str).'<br>';
	echo preg_replace('#ab{4,}a#', '!', $str).'<br>';
?> -->

<!-- 191 Ограничение жадности в регулярках в PHP
Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов. -->
<!--
Пусть мы в этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a',
затем любой символ один или более раз, затем буква 'x'.
этом случае мы бы хотели отменить жадность и сказать регулярке, чтобы она искала до первого икса.
Чтобы ограничить жадность, нужно после оператора повторения поставить знак вопроса:-->
<!-- <?php
	$str = 'aeeex zzz x kkk';
	echo preg_replace('#a.+x#', '!', $str).'<br>';
	echo preg_replace('#a.+?x#', '!', $str).'<br>';
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет все строки по краям которых стоят буквы 'a',
и заменит каждую из них на '!'. Между буквами a может быть любой символ (кроме 'a'). -->
<!-- <?php
	$str = 'aba accca azzza wwwwa';
	echo preg_replace('#a.+?a#', '!', $str);
?> -->

<!-- 192 Группы символов в регулярных выражениях PHP -->
<!--
Существуют специальные команды, которые позволяют выбрать сразу целые группы символов.
Команда \d означает цифру от 0 до 9.
Команда \w обозначает цифру, латинскую букву или знак подчеркивания.
Команда \s обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию.
Можно инвертировать значение команды, написав большую букву:
например, если \d - цифра, то \D - не цифра. -->
<!--
Давайте найдем все цифры: -->
<!-- <?php
	$str = '1 12 123';
	echo  preg_replace('#\d#', '!', $str);
?> -->

<!-- Операторы повторения считают команды-группы одним целым, то есть группирующие скобки не нужны.
В следующем примере шаблон поиска выглядит так: цифра от 0 до 9 один или более раз: -->
<!-- <?php
	$str = '1 12 123 abc @@@';
	$res = preg_replace('#\d+#', '!', $str);
?> -->

<!-- В следующем примере шаблон поиска выглядит так: все что угодно один или более раз, но не цифра от 0 до 9: -->
<!-- <?php
	$str = '123abc3@@';
	echo preg_replace('#\D+#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: пробельный символ один раз: -->
<!-- <?php
	$str = '1 12 123 abc @@@';
	echo  preg_replace('#\s#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: НЕ пробельный символ один или более раз.
Все подстроки, разделенные пробелами, заменятся на '!': -->
<!-- <?php
	$str = '1 12 123 abc @@@';
	echo preg_replace('#\S+#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: цифра или буква один или более раз.
Все подстроки, состоящие из цифр и букв, заменятся на '!': -->
<!-- <?php
	$str = '1 12 123a Abc @@@';
	echo preg_replace('#\w+#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: НЕ цифра и НЕ буква один или более раз.
Под данное определение в нашем случае попадает '@@@' и все пробелы (они ведь тоже не цифры и не буквы).
Обратите внимание на то, что в конце один '!' - в него преобразовалась строка ' @@@' - с пробелом впереди: -->
<!-- <?php
$str = '1 12 123 Abc @@@';
echo preg_replace('#\W+#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними одна цифра. -->
<!-- <?php
	$str = 'a1a a2a a3a a4a a5a aba aca';
	echo preg_replace('#a\da#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр. -->
<!-- <?php
	$str = 'a1a a22a a333a a4444a a55555a aba aca';
	echo preg_replace('#a\d+a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a',
а между ними любое количество цифр (в том числе и ноль цифр, то есть строка 'aa'). -->
<!-- <?php
	$str = 'aa a1a a22a a333a a4444a a55555a aba aca';
	echo preg_replace('#a\d*a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не число. -->
<!-- <?php
	$str = 'avb a1b a2b a3b a4b a5b abb acb';
	echo preg_replace('#a\Db#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не буква и не цифра. -->
<!-- <?php
	$str = 'ave a#b a2b a$b a4b a5b a-b acb';
	echo preg_replace('#a\Wb#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая заменит все пробелы на '!' -->
<!-- <?php
	$str = 'ave a#a a2a a$a a4a a5a a-a aca';
	echo preg_replace('#\s#', '!', $str);
?> -->

<!-- 193 Наборы символов в регулярных выражениях PHP -->

<!-- Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: #x[abc]x# -
мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.

После квадратных скобок можно писать операторы повторения. К примеру, вот так: #x[abc]+x# - мы говорим,
что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.

Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис.
К примеру, вот так: #[a-d]# - мы получаем все символы от 'a' до 'd'. -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xax xbx xcx x@x';
	echo preg_replace('#x[a-z]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'k':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xax xbx xmx x@x';
	echo preg_replace('#x[a-k]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква от 'A' до 'Z':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xax xBx xcx x@x';
	echo preg_replace('#x[A-Z]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая цифра от 0 до 9: -->
<!-- <?php
	$str = 'xax x1x x3x x5x x@x';
	echo preg_replace('#x[0-9]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая цифра от 3 до 7: -->
<!-- <?php
	$str = 'xax x1x x3x x5x x@x';
	echo preg_replace('#x[3-7]x#', '!', $str);
?> -->
<!--
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9: -->
<!-- <?php
	$str = 'xax x1x x3x x5x x@x';
	echo preg_replace('#x[a-z1-9]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z': -->
<!-- <?php
	$str = 'xax xBx xcx x5x x@x';
	echo $res = preg_replace('#x[a-zA-Z]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2: -->
<!-- <?php
	$str = 'xax xbx x1x x2x x3x';
	echo preg_replace('#x[a-z12]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами буквы от 'a' до 'z' в количестве от 1 и более: -->
<!-- <?php
	$str = 'xx xabesx xaadx x123x xa3x';
	echo preg_replace('#x[a-z]+x#', '!', $str);//xx ! ! x123x xa3x
?> -->

<!-- Сделаем так, чтобы количество букв могло быть и ноль: -->
<!-- <?php
	$str = 'xx xabesx xaadx x123x xa3x';
	echo preg_replace('#x[a-z]*x#', '!', $str); //! ! ! x123x xa3x
?> -->
<!--
Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква 'b', 'e' или 'x'. -->
<!-- <?php
	$str = 'aba aea aca aza axa';
	echo preg_replace('#a[bex]a#', '!', $str);//! ! aca aza !
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - цифра от 3-х до 6-ти. -->
<!-- <?php
	$str = 'a1a a3a a7a a9a aba';
	echo preg_replace('#a[3-6]a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до g. -->
<!-- <?php
	$str = 'aba aea afa aha aga';
	echo preg_replace('#a[a-g]a#', '!', $str);//! ! ! aha !
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от j до z. -->
<!-- <?php
	$str = 'aba aea afa aha aga aka';
	echo preg_replace('#a[a-fj-z]a#', '!', $str);//! ! ! aha aga
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от A до D. -->
<!-- <?php
	$str = 'aAa aea aEa aJa a3a';
	echo preg_replace('#a[a-fA-D]a#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a',
а между ними - маленькие латинские буквы, не затронув остальных. -->
<!-- <?php
	$str = 'aAXa aeffa aGha aza ax23a a3sSa';
	echo preg_replace('#a[a-z]+a#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a',
а между ними - маленькие и большие латинские буквы, не затронув остальных. -->
<!-- <?php
	$str = 'aAXa aeffa aGha aza ax23a a3sSa';
	echo preg_replace('#a[a-zA-Z]+a#', '!', $str);//! ! ! ! ax23a a3sSa
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a',
а между ними - маленькие латинские буквы и цифры, не затронув остальных. -->
<!-- <?php
	$str = 'aAXa aeffa aGha aza ax23a a3sSa';
	echo preg_replace('#a[a-z1-9]+a#', '!', $str);
?> -->

<!-- 194 Инвертирование наборов символов в регулярках -->

<!-- С помощью шляпки ^ в начале квадратных скобок можно инвертировать желаемое.
То есть, если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'. -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ буква 'a', не 'b' и не 'c', потом буква 'z': -->
<!-- <?php
	$str = 'xaz xbz xcz xez';
echo preg_replace('#x[^abc]z#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ маленькая латинская буква, потом буква 'z': -->
<!-- <?php
	$str = 'xaz xbz x1z xCz';
	echo preg_replace('#x[^a-z]z#', '!', $str);
?> -->
<!--
Напишите регулярку, которая найдет строки по шаблону: цифра '1', затем символ не 'e' и не 'x', цифра '2'. -->
<!-- <?php
$str = '1bdf2 1ex2 1x2 1e2 1d2';
echo preg_replace('#1[^ex]+2#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ цифра от 2 до 7, буква 'z'. -->
 <!-- <?php
 $str = 'x1z xrz x9z x5z';
 echo preg_replace('#x[^2-7]z#', '!', $str);
 ?> -->
<!--
Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая латинская буква от 1 и более раз, буква 'z'. -->
<!-- <?php
 $str = 'x1z xrz x9z  xCz zvfvz x456z x5z xCDFz';
 echo preg_replace('#x[^A-Z]+z#', '!', $str); //! xCz zvfvz ! xCDFz
 ?> -->

<!-- Напишите регулярку, которая найдет строки по шаблону: буква 'x',
затем не большая и не маленькая латинская буква и не цифра от 1 до 5 от 1 и более раз, буква 'z'. -->
<!-- <?php
$str = 'x1z xrz x9z  xCz zvfvz x456z x5z xCDFz';
 echo preg_replace('#x[^a-zA-Z1-5]+z#', '!', $str);
 ?> -->
<!--
 195 Особенности кириллицы в регулярках PHP
Кириллические символы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я].
Но даже с этой группой есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно сделать вот так: [а-яё]. -->

<!-- Кроме того, для корректной работы кириллицы в регулярке необходимо поставить модификатор u: -->
<!-- <?php
	$str = 'яяя ййй ёёё';
	echo preg_replace('#[а-яё]#u', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'w', а между ними - буква кириллицы. -->
<!-- <?php
	$str = 'wйw wяw wёw wqw';
	echo preg_replace('#w[а-яё]w#u', '!', $str);
?> -->
<!--
Дана строка:
Напишите регулярку, которая найдет все слова по шаблону: любая кириллическая буква любое количество раз. -->
<!-- <?php
	$str = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';
	echo preg_replace('#[А-ЯЁа-яё]+#u', '!', $str);
?> -->
<!--
 196 Спецсимволы внутри квадратных скобок в PHP -->
<!--
Спецсимволы внутри [] становятся обычными символами. Это значит, что их не надо экранировать обратным слешем. -->
<!-- В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'xax xbx xcx xdx x.x x@x';
	echo preg_replace('#x[abc.]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или точка: -->
<!-- <?php
	$str = 'xax xbx xcx x@x';
	echo preg_replace('#x[a-z.]x#', '!', $str);
?> -->
<!--
Дана строка:
Напишите регулярку, которая найдет строки 'a.a', 'a+a', 'a*a', не затронув остальных. -->
<!-- <?php
	$str = 'aba aea aca aza axa a.a a+a a*a';
	echo preg_replace('#a[.+*]a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ точка, НЕ собака, и НЕ доллар, а потом буква 'z'. -->
<!-- <?php
	$str = 'xaz x.z x3z x@z x$z xrz';
	echo preg_replace('#x[^.@$]z#', '!', $str);
?> -->

 <!-- 197 Группы символов внутри квадратных скобок PHP -->

<!-- Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами. -->
<!--
В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f': -->
<!-- <?php
	$str = 'xax xbx x1x x2x xhx x@x';
	echo preg_replace('#x[\da-f]x#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z': -->
<!-- <?php
	$str = 'xaz x1z xAz x.z x@z';
	echo preg_replace('#x[^\d.a-z]z#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет строки по шаблону: цифра или точка от 1 и более раз. -->
 <!-- <?php
 $str = '111 123 123 15. ... asb 123';
 echo preg_replace('#[\d.]+#', '!', $str);
 ?> -->

<!-- Напишите регулярку, которая найдет строки по шаблону: не цифра и не буква от 'a' до 'g' от 3 до 7 раз. -->
 <!-- <?php
 $str = 'af fddf 3354 tttg uuui assd 11133 ggfg 4455 $$$  &&& *&*&';
 echo preg_replace('#[^\da-g]{3,7}#', '!', $str);
 ?> -->

<!-- 198 Исключения внутри наборов в регулярках в регулярках PHP -->

<!-- Вы уже знаете, что спецсимволы внутри [] становятся обычными символами. Есть, однако, исключения:
если вам нужны квадратные скобки как символы, то их нужно экранировать обратным слешем.
Для примера в следующем коде шаблон поиска выглядит так: между иксами стоит квадратная скобка: -->

<!-- <?php
	$str = 'x]x xax x[x x1x';
	echo preg_replace('#x[\[\]]x#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем любое количество любых скобок, затем буква 'z'. -->
<!-- <?php
	$str = 'x[]z x{}z x.z x()z';
	echo preg_replace('#x[\[\]\(\)\{\}]+z#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки в любых скобках и заменят их на '!'. -->
<!-- <?php
	$str = '[abc] {abc} abc (abc) [abc] abc';
	echo preg_replace('#[\[a-c\]\(a-c\)\{a-c\}]+#', '!', $str);
	?>  -->

 <!-- 199 Символ шляпки внутри наборов в регулярках PHP -->
<!--
 Как вы знаете, шляпка внутри [] делает отрицание, будучи написанной в начале скобок. Значит,
 она является спецсимволом внутри этих скобок.
 Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места. -->

 <!-- В следующем примере шаблон поиска такой: первый символ - это все кроме 'd', потом две буквы 'x'. -->
<!-- <?php
	$str = 'axx bxx ^xx dxx';
	echo $res = preg_replace('#[^d]xx#', '!', $str);
?> -->

<!-- А теперь шаблон поиска такой: первый символ - это 'd' или '^', потом две буквы 'x': -->
<!-- <?php
	$str = 'axx bxx ^xx dxx';
	echo preg_replace('#[d^]xx#', '!', $str);
?> -->

<!-- Можно не убирать шляпку с первого места, а просто заэкранировать ее с помощью обратного слеша, и она станет обозначать саму себя: -->
<!-- <?php
	$str = 'axx bxx ^xx dxx';
	echo preg_replace('#[\^d]xx#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: шляпка или собака, а затем две латинских буквы. -->
<!-- <?php
	$str = '^xx axx ^zz bkk @ss';
	echo preg_replace('#[@^][a-z]{2}#', '!', $str);//! axx ! bkk !
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: НЕ шляпка и не собака, а затем две латинских буквы. -->
<!-- <?php
	$str = '^xx axx ^zz bkk @ss';
	echo preg_replace('#[^@^][a-z]{3}#', '!', $str);//^xx! ^zz! @ss
?> -->
<!--
Дана строка:
Напишите регулярку, которая найдет строки по шаблону: НЕ шляпка, а затем две латинских буквы. -->
<!-- <?php
	$str = '^xx axx ^zz bkk';
	echo preg_replace('#[^\^][a-z]{3}#', '!', $str);//^xx! ^zz!
?> -->
<!--
200 Дефис внутри наборов в регулярках PHP -->

<!-- Дефис - тоже спецсимвол внутри [] (а вот снаружи - нет).
Если вам нужен сам дефис как символ - то поставьте его там, где он не будет воспринят как разделитель группы. -->

<!-- Как с этим бороться: поставьте символ дефиса там, где он точно не будет воспринят как символ группы, например,
в начале или в конце (то есть после [ или перед ]).

Можно также заэкранировать дефис - тогда он будет обозначать сам себя независимо от позиции.
Например, вместо [:-@] написать [:\-@] - и группы уже не будет,
а будут три символа - двоеточие, дефис и собака @ -->
<!--
В следующем примере шаблон поиска такой: цифра 1, затем буква от 'a' до 'z', затем цифра 2: -->
<!-- <?php
	$str = '1a2 1-2 1c2 1z2';
	echo preg_replace('#1[a-z]2#', '!', $str);
?> -->

<!-- Давайте теперь заэкранируем дефис. В результате шаблон поиска такой: цифра 1, затем буква 'a', или дефис, или буква 'z', затем цифра 2:
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = '1a2 1-2 1c2 1z2';
	echo  preg_replace('#1[a\-z]2#', '!', $str);
?> -->
<!--
Можно просто переставить дефис, не экранируя его:
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = '1a2 1-2 1c2 1z2';
	echo preg_replace('#1[az-]2#', '!', $str);
?> -->
<!--
В следующем примере шаблон поиска такой: первый символ - это маленькие буквы или дефис '-', потом две буквы 'x':
В результате в переменную запишется следующее: -->
<!-- <?php
	$str = 'axx Axx -xx @xx';
	echo preg_replace('#[a-z-]xx#', '!', $str);//! Axx ! @xx
?> -->

<!-- В следующем примере шаблон поиска такой: первый символ - это маленькие, большие буквы или дефис '-', потом две буквы 'x': -->
<!-- <?php
	$str = 'axx Axx -xx @xx';
	echo preg_replace('#[a-zA-Z-]xx#', '!', $str); //! ! ! @xx
?> -->

<!-- Можно расположить дефис между двумя группами - там он точно еще не сделает еще одну группу: -->
<!-- <?php
	$str = 'axx 9xx -xx @xx';
	echo preg_replace('#[a-z-0-9]xx#', '!', $str);//! ! ! @xx
?> -->

<!-- Дана строка:
Найдите все строки по следующему шаблону: буква 'x', большая или маленькая буква или дефис, буква 'z'. -->
<!-- <?php
	$str = 'xaz xBz xcz x-z x@z';
	echo preg_replace('#x[a-zA-Z-]z#', '!', $str);//! ! ! ! x@z
?> -->

<!-- Дана строка:
Найдите все строки по следующему шаблону: буква 'x', затем или доллар, или дефис или плюс, потом буква 'z'. -->
<!-- <?php
	$str = 'xaz x$z x-z xcz x+z x%z x*z';
	echo preg_replace ('#x[$\-+]z#', '!', $str);//xaz ! ! xcz ! x%z x*z
?> -->
<!--
201 Начало и конец строки в регулярках PHP -->

<!-- Существуют специальные символы, которые обозначают начало ^ или конец строки $. Давайте посмотрим их работу на примерах. -->

<!-- В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки: -->
<!-- <?php
	$str = 'aaa aaa aaa';
	echo preg_replace('#^aaa#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки: -->
<!-- <?php
	$str = 'aaa aaa aaa';
	echo preg_replace('#aaa$#', '!', $str);
?> -->

<!-- Когда в начале регулярки стоит ^, а в конце - $, то таким образом мы проверяем всю строку целиком на соответствие регулярке.
В следующем примере шаблон поиска такой: буква 'a' повторяется один или более раз,
заменить всю строку на '!' только она состоит из одних букв 'a'. -->
<!-- <?php
	$str = 'aaa';
	echo preg_replace('#^a+$#', '!', $str);
	?> -->
<!--
Напишите регулярку, которая найдет первую подстроку из букв. -->
<!-- <?php
	$str = 'abc def xyz';
	echo preg_replace('#^[a-z]{3}#', '!', $str);
?> -->

<!-- Напишите регулярку, которая найдет последнюю подстроку из букв. -->
<!-- <?php
	$str = 'abc def xyz';
	echo preg_replace('#[a-z]{3}$#', '!', $str);
?> -->

<!-- 202 Конец или начало слова в регулярках PHP -->

<!-- Команда \b обозначает начало или конец слова, а \B, соответственно, - не начало и не конец слова.
Что такое слово? На первый взгляд кажется, что это нечто, ограниченное пробелами, но это не совсем так -->

<!-- В следующем примере шаблон поиска такой: начало слова, маленькие латинские буквы один или более раз, конец слова.
Таким образом, регулярка найдет все слова и заменит их на '!': -->
<!-- <?php
	echo preg_replace('#\b[a-z]+\b#', '!', 'axx bxx xxx exx'); // выведет '! ! ! !'
?> -->
<!--
Дана строка:
Напишите регулярку, которая найдет строки по шаблону: буква 'x' в начале слова. -->
<!-- <?php
	$str = 'aaa xaa aaa xbb aaa';
	echo preg_replace('#\bx[a-z]+#', '!', $str);//aaa ! aaa ! aaa
?> -->

<!-- 203 Команда 'или' в регулярных выражениях PHP -->

<!-- В данном уроке мы разберем команду |, которая представляет собой более мощный вариант ИЛИ по сравнению с командой [].
Данная команда позволяет разделить регулярку на несколько частей.
При этом искомое может попасть либо под одну часть регулярки, либо под другую. Давайте посмотрим на примерах. -->
<!--
В данном примере шаблон поиска такой: три буквы 'a' или три буквы 'b': -->
<!-- <?php
	$str = 'aaa bbb abb';
	echo preg_replace('#a{3}|b{3}#', '!', $str);
?> -->
<!--
В данном примере шаблон поиска такой: три буквы 'a' или от 1 и более букв 'b': -->
<!-- <?php
	$str = 'aaa bbb bbbb bbbbb axx';
echo preg_replace('#a{3}|b+#', '!', $str);
?> -->

<!-- В данном примере шаблон поиска такой: одна или более буквы или три цифры: -->
<!-- <?php
	$str = 'a ab abc 1 12 123';
	echo preg_replace('#[a-z]+|\d{3}#', '!', $str);
?> -->

<!-- Вертикальная черта может делить регулярку не на две части, а на любое количество частей: -->
<!-- <?php
	$str = 'aaa bbb ccc ddd';
	echo preg_replace('#a+|b+|c+#', '!', $str);
?> -->

<!-- Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок.
 Для примера давайте найдем строки по следующему шаблону: в начале стоит или 'a', или 'b' один или более раз, а потом две буквы 'x': -->
<!-- <?php
	$str = 'axx bxx bbxx exx';
	echo preg_replace('#(a|b+)xx#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e'
любое количество раз или буква 'x' любое количество раз. -->
<!-- <?php
	$str = 'aeeea aeea aea axa axxa axxxa';
	echo preg_replace('#a(e+|x+)a#', '!', $str);
?> -->

<!-- Дана строка:
Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a',
а между ними - или буква 'e' два раза или буква 'x' любое количество раз. -->
<!-- <?php
	$str = 'aeeea aeea aea axa axxa axxxa';
	echo preg_replace('#a(e{2}|x+)a#', '!', $str);
?> -->
<!--
204 Ограничители регулярок в PHP -->
<!--
В качестве ограничителей могут выступать не только #, но и любые другие символы (только не буквы и не цифры).
К примеру, возьмем в качестве ограничителей символы амперсандов:
Если используются скобки, тогда левый ограничитель - это открывающая скобка, а правый - закрывающая: -->
<!-- <?php
	echo preg_replace('&а+&', '!', 'строка');
?>
<?php
	echo preg_replace('(а+)', '!', 'строка');
?> -->
<!--
Используйте в качестве ограничителей символ тильды ~. -->
<!-- <?php
	$str = 'aeeea aeea aea axa axxa axxxa';
	echo preg_replace('~a(e{2}|x+)a~', '!', $str);
	?> -->

<!-- 205 Экранировка ограничителей в PHP -->
<!--
Если символ не является специальным, то, когда вы используете его в качестве ограничителя,
его нужно будет экранировать в самой регулярке. Посмотрим на примере.
Пусть у нас в качестве ограничителей выступают решетки, а внутри регулярки мы ищем символ амперсанда.
Так как амперсанд не является спецсимволовм, то мы его не экранируем: -->
<!-- <?php
	echo preg_replace('#a&b#', '!', 'a&b'); // выведет '!'
?> -->
<!-- Пусть теперь ограничители - амперсанды и внутри регулярки нам также нужен амперсанд.
В таком случае амперсанд внутри приходится экранировать, иначе это вызовет ошибку PHP: -->
<!-- <?php
	echo preg_replace('&a\&b&', '!', 'a&b'); // выведет '!'
?> -->

<!-- Исправьте ошибку, допущенную в следующем коде: -->
<!-- <?php
	echo preg_replace('#a\#b#', '!', 'a#b');
?> -->

<!-- 206 Проблема обратного слеша в PHP -->

<!-- Обратный слеш является спецсимволом PHP. Это значит, что в строке, если мы хотим, чтобы слеш обозначал сам себя, мы должны его удвоить: -->
<!-- <?php
	$str = '\\ \\\\ \\\\\\'; // на самом деле строка '\ \\ \\\'
?> -->
<!--
Давайте теперь напишем регулярку, в которой шаблон поиска будет такой: обратный слеш один или более раз.
 В таком случае мы напишем оператор + аж для 4 символов перед ним без группировки: -->
<!-- <?php
	echo preg_replace('#\\\\+#', '!', '\\ \\\\ \\\\\\'); // выведет '! ! !'
?> -->

<!-- Дана строка:
Найдите в этой строке все подстроки по шаблону буква, обратный слеш, буква. -->
<!-- <?php
	$str = 'a\\b c\\d e\\f';
	echo preg_replace('#[a-z]\\\\[a-z]#', '!', $str);
?> -->

<!-- Дана строка:
Найдите в этой строке все подстроки по шаблону буква, обратный слеш любое количество раз, буква. -->
<!-- <?php
	$str = 'a\\b c\\\\d e\\\\\\f';
	echo preg_replace('#[a-z]\\\\+[a-z]#', '!', $str);
?> -->

<!-- 207 Проверка строки с помощью регулярки на PHP -->

<!-- Поиском и заменой возможности регулярок далеко не исчерпаны.
Существует также функция preg_match, которая проверяет, есть ли в строке совпадение с регуляркой.
Первым параметром функция принимает регулярное выражение, а вторым - строку для поиска.
При этом, если совпадений будет много, - функция найдет только первое и закончит свою работу.
Поэтому функция выводит либо 1, либо 0 и используется для ответа на вопрос 'есть искомое в строке или нет'.
Вернет один - значит есть (а сколько раз - неясно), вернет ноль - значит нет. -->
<!--
Давайте посмотрим на примерах. Проверим, есть ли в строке подстрока, состоящая из букв 'a', повторенных один или более раз: -->
<!-- <?php
	echo preg_match('#a+#', 'eee aaa bbb'); // выведет 1
?> -->

<!-- Определите, есть ли в строке 3 цифры подряд. -->
 <!-- <?php
	echo preg_match('#\d{3}#', '11 13 1 14 aaa bbb'); // выведет 1
	?>  -->

<!-- Определите, начинается ли переданная строка с http. -->
<!-- <?php
	echo preg_match('#^http.+#', 'http:www/leningrad.ru'); // выведет 1
	?>  -->

<!-- Определите, начинается ли переданная строка с http или с https. -->
<!-- <?php
	echo preg_match('#^(http|https)://#', 'https://wwwleningrad.ru'); // выведет 1
	?> -->

<!-- Определите, заканчивается ли переданная строка расширением txt, html или php. -->
<!-- <?php
	echo preg_match('#\.(txt|html|php)$#', 'leningrad.pha'); // выведет 1
	?>  -->

<!-- 208 Автоматическое тестирование регулярок в PHP -->

<!-- Давайте напишем код, который позволит нам удобно тестировать написанные нами регулярки сразу на нескольких строках. -->

<!-- Соберем весь код вместе и получим удобную заготовку для тестирования регулярок: -->
<!-- <?php
	//$reg   = '#\d{3,}#'; // ваша регулярка
	//$arr[] = 'aaa 123 bbb';   // 1
	//$arr[] = 'aaa 12345 bbb'; // 1
	//$arr[] = 'aaa 12x bbb';   // 0
	//$arr[] = 'aaa 12 bbb';    // 0
	//foreach ($arr as $str) {
		//echo $str . ' ' . preg_match($reg, $str) . '<br>';
	//}
?> -->

<!-- Пусть вам нужно проверить, что в строке есть дробное число.
Используя предложенный скрипт, проверьте вашу регулярку на различных строках. -->
<!-- <?php
	//$reg   = '#\d+\,\d+#'; // ваша регулярка
	//$arr[] = 'aaa 123 bbb';   // 1
	//$arr[] = 'aaa 1,2345 bbb'; // 1
	//$arr[] = 'aaa 12x bbb';   // 0
	//$arr[] = 'aaa 12 bbb';    // 0
	//foreach ($arr as $str) {
		//echo $str . ' ' . preg_match($reg, $str) . '<br>';
	//}
?> -->

<!-- 209 Проверка всей строки через регулярки в PHP -->

<!-- Часто preg_match используется для проверки на соответствие регулярному выражению всей строки.
В таком случае в начале регулярки следует поставить шляпку ^, а в конце - доллар $.
Этим мы говорим, что под шаблон должна попасть вся строка.
Давайте для примера узнаем, состоит ли строка целиком из букв 'a', или нет: -->
<!-- <?php
	echo preg_match('#^a+$#', 'aaaa'); // выведет 1
	echo preg_match('#^a+$#', 'aaab'); // выведет 0
?> -->

<!-- Определите, является ли переданная строка является доменом. Используйте для тестов следующие строки: -->
<!-- <?php
	//$arr[] = 'site.ru';          // +
	//$arr[] = 'site.com';         // +
	//$arr[] = 'my-site.com';      // +
	//$arr[] = 'my-cool-site.com'; // +
	//$arr[] = 'my_site.com';      // +
	//$arr[] = 'site123.com';      // +
	//$arr[] = 'site.travel';      // +
	//$arr[] = 'si$te.com';        // -
	//$arr[] = 'site.r';           // -
//$reg = ('#ru$|com$#');
//foreach ($arr as $str){
	//echo $str . ' ' . preg_match($reg, $str) . '<br>';
//}
?> -->

<!-- Определите, является ли переданная строка является емейлом. Используйте для тестов следующие строки: -->
<!-- <?php
//$reg = ('#^[a-z1-9\-\_]+@[a-z]+\.ru$#');
//	$arr[] = 'addr@mail.ru';    // +
//	$arr[] = 'addr123@mail.ru'; // +
	//$arr[] = 'my-addr@mail.ru'; // +
//	$arr[] = 'my_addr@mail.ru'; // +
//	$arr[] = 'addr@site.ru';    // +
//	$arr[] = 'addr.ru';         // -
//	$arr[] = 'addr@.ru';        // -
//	$arr[] = 'my@addr@mail.ru'; // -

	//foreach ($arr as $str){
	//	echo $str . ' ' . preg_match($reg, $str) . '<br>';
	//}
?> -->
<!--
210 Карманы при поиске через регулярки на PHP -->
<!--
Пусть у нас есть некоторая строка, содержащая домен:
<!-- <?php
	//$str = 'eee site.ru bbb';
?> -->
<!-- Давайте найдем этот домен и разделим его на части: отделим имя домена от его зоны.
Для этого мы используем специальные карманы регулярных выражений.  -->
<!-- Карманы представляют собой элементы массива, в которые можно положить части найденного регуляркой.
В нашем случае в первый карман мы можем положить имя домена, а во второй - его зону. -->

<!-- Давайте теперь в нашей регулярке обозначим, какие части в какой карман должны попадать.
 Это делается с помощью круглых скобок. Давайте выделим с их помощью часть регулярки,
 которая ищет имя домена, и ту часть, которая ищет доменную зону: -->
<!-- <?php
	//$reg = '#([a-z0-9_-]+)\.([a-z]{2,})#';
?> -->
<!-- Теперь в функции preg_match в качестве третьего параметра укажем переменную (имя любое): -->
<!-- <?php
	preg_match($reg, $str, $res);
?> -->
<!--
В указанную переменную попадет массив с найденными карманами.
При этом в нулевом элементе массива будет лежать найденная строка,
в первом элементе - первый карман, во втором элементе - второй карман и так далее: -->
<!-- <?php
	preg_match($reg, $str, $res);
	var_dump($res); // выведет ['site.ru', 'site', 'ru']
?> -->

<!--
Дана строка с датой:
Положите год, месяц и день в отдельные карманы. -->
<!-- <?php
$str = '2025-12-31';
$reg = '#([0-9]{4})\-([0-9]{2})\-([0-9]{2})#';
	preg_match($reg, $str, $res);
	var_dump($res);
?> -->

<!-- Дана строка с именем файла:
Положите имя файла и его расширение в отдельные карманы. -->
<!-- <?php
	$str = 'index.html';
	$reg = '#([a-z]+)\.([a-z]+)#';
	preg_match($reg, $str, $res);
	var_dump($res);
?> -->

<!-- 211 Поиск всех совпадений через регулярки на PHP -->

<!-- С помощью функции preg_match_all можно узнать количество всех совпадений с регулярным выражением: -->
<!-- <?php
	$str = 'a aa aaa bbb';
	echo preg_match_all('#a+#', $str); // выведет 3
?> -->

<!-- Дана строка. Узнайте, сколько чисел в этой строке. -->
 <!-- <?php
 $str = '123 333 44 66';
 echo preg_match_all('#\d+#', $str);
 ?> -->

 <!-- 212 Все совпадения на карманы через регулярки в PHP -->

 <!-- С помощью функции preg_match_all можно разделить все найденные совпадения на карманы. Давайте посмотрим, как это делается.
Пусть, например, у нас есть строка с доменами: -->
<!-- <?php
	$str = 'site.ru site123.com my-site.net';
?> -->
<!-- Давайте напишем регулярное выражение на поиск домена, отделив имя и зону в отдельные карманы: -->
<!-- <?php
	$reg = '#([a-z0-9_-]+)\.([a-z]{2,})#';
?> -->
<!-- Результат попадет в третий параметр функции: -->
<!-- <?php
	preg_match_all($reg, $str, $res);
	var_dump($res);
?> -->
<!--
В результате мы получим двухмерный массив.
В нулевой элемент этого массива попадет содержимое нулевых карманов (то есть то, что попало под всю регулярку),
во второй элемент - содержимое первых карманов и так далее: -->
<!-- <?php
	[
		['site.ru', 'site123.com', 'my-site.net'],
		['site', 'site123', 'my-site'],
		['ru', 'com', 'net'],
	]
?> -->
<!-- <?php
$str = 'site.ru site123.com my-site.net';
$reg  = '#([a-z0-9_-]+)\.([a-z]{2,})#';
preg_match_all($reg, $str, $res);
echo '<pre>';
print_r($res);
echo '<pre>';
?> -->

<!-- Дана строка с датами:
Найдите все даты, отделив год, месяц и день в отдельные карманы. -->
<!-- <?php
	$str = '2023-10-29 2024-11-30 2025-12-31';
	$reg = '#([0-9]{4})\-([0-9]{2})\-([0-9]{2})#';
	preg_match_all($reg, $str,$res);
echo '<pre>';
print_r($res);
echo '<pre>';
?> -->
<!--
213 Изменение поведения preg_match_all в PHP -->

<!-- С помощью четвертого параметра функции можно поменять способ группировки карманов.
Подробную информацию об этом посмотрите по ссылке http://www.php.su/functions/?preg-match-all. -->

<!-- 214 Несохраняющие скобки в регулярках PHP -->

<!-- Скобки () выполняют две функции - группировка символов и функцию кармана.
А что делать, если нам нужно сгруппировать, но в карман не класть?
Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман. -->

<!-- В следующем примере первые скобки нам нужны для группировки, а вторые - для кармана. Однако, и те, и другие скобки сохраняют данные в карман: -->
<!-- <?php
	$str = 'abab123';
	$reg = '#(ab)+([1-9]+)#';
	preg_match_all($reg, $str, $res);
	var_dump($res[0]); // выведет 'abab123'
	var_dump($res[1]); // выведет 'ab'
	var_dump($res[2]); // выведет '123'
?> -->

<!-- Сделаем так, чтобы первая пара скобок только группировала, но не клала в карман:
В результате в первом кармане будет наше число: -->
<!-- <?php
	$str = 'abab123';
	$reg = '#(?:ab)+([1-9]+)#';
	preg_match_all($reg, $str, $res);
	var_dump($res[1]); // выведет '123'
?> -->
<!--
Даны подстроки, разделенные на две части произвольным количеством пар $@:
Найдите каждую из таких подстрок и для каждой найденной подстроки положите в первый карман то,
 что стоит до разделителя, а во второй карман - то, что стоит после разделителя. -->
<!-- <?php
	$str = 'aaa$@bbb aaa$@$@bbb aaa$@$@$@bbb';
	$reg = '#(a+)\$\@(b+)#';
	preg_match_all($reg, $str, $res);
	print_r($res);
?> -->

<!-- 215 Карманы при замене через регулярки на PHP -->

<!-- При работе с функцией preg_replace, если мы что-то положим в карман в регулярке,
то в строке замены мы можем вставить содержимое этого кармана написав знак доллара $ и номер кармана.
Например, $0 - нулевой карман, $1 - первый карман, $2 - второй карман и так далее.
Зачем это нужно и как этим пользоваться давайте посмотрим на примерах. -->

<!-- Давайте найдем все числа и вместо них вставим эти же числа, но в фигурных скобках.
Для этого все найденные числа мы будем заменять на них самих же, но в фигурных скобках: -->
<!-- <?php
	$str = '1 23 456 xax';
	echo preg_replace('#(\d+)#', '{$1}', $str);
?> -->

<!-- Давайте найдем все строки, представляющие собой числа с иксами вокруг и заменим эти числа на них же, но с '!' знаками вокруг: -->
<!-- <?php
	$str = 'x1x x23x x456x xax';
	echo preg_replace('#x(\d+)x#', '!$1!', $str);
?> -->
<!--
Давайте решим следующую задачу: даны строки вида 'aaa@bbb' - буквы, потом собака, потом буквы.
 Нужно поменять местами буквы до '@' и после. Реализуем: -->
<!-- <?php
	$str = 'aaa@bbb ccc@ddd';
	echo preg_replace('#([a-z]+)@([a-z]+)#', '$2@$1', $str);
?> -->

<!-- Дана строка:
Поменяйте местами цифры во всех двухзначных числах. -->
<!-- <?php
	$str = '12 34 56 78';
	echo preg_replace('#([0-9]{1})([0-9]{1})#', '$2$1', $str);
?> -->

<!-- Дана строка с датой:
Преобразуйте эту дату в '2025.12.31'. -->
<!-- <?php
	$str = '31.12.2025';
	echo preg_replace('#([0-9]{2}).([0-9]{2}).([0-9]{4})#', '$3.$2.$1', $str);
?> -->

<!-- 216 Карманы в регулярном выражении в PHP -->
<!--
Содержимое карманов доступно не только в строке замены, но в и самой регулярке: мы можем положить что-нибудь в карман,
а затем прямо в регулярке сказать,
что здесь должно стоять содержимое этого кармана.
Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш.
Например, нулевой карман будет доступен вот так: \0, первый карман вот так - \1, второй - \2 и так далее. -->

<!-- Пусть у нас есть вот такая строка:
Давайте найдем в ней все места, в которых стоят две любые одинаковые буквы подряд.
Для решения задачи будем искать любую букву, класть ее в карман, а затем проверять, идет ли следующем символом содержимое этого кармана: -->
<!-- <?php
	$str = 'aa bb cd ef';
	echo preg_replace('#([a-z])\1#', '!', $str);
?> -->

<!-- Пусть у нас есть вот такая строка:
Давайте найдем в ней все слова, в которых одинаковы первая и последняя буквы.
Для решения задачи напишем следующий шаблон: буква, затем еще одна или более букв, а затем такая же буква как первая: -->
<!-- <?php
	$str = 'asxca buzxb csgd';
	echo preg_replace('#([a-z])[a-z]+\1#', '!', $str);
?> -->

<!-- Вместо \1 можно писать \g1:
Можно также писать \g{1}: -->
<!--
В фигурных скобках можно указывать отрицательные числа. В этом случае карманы будут отсчитываться с конца: -->
<!-- <?php
$str = 'acsxca buzxb dcsgd';
	echo preg_replace('#([a-z])([a-z])\g{-2}#', '!', $str);
?> -->

<!-- Дана строка:
Найдите все подстроки, в которых есть три одинаковые буквы подряд. -->
<!-- <?php
	$str = 'aaa bbb ccc xyz';
	echo preg_replace('#([a-z])+\1#', '!', $str);
?> -->

<!-- Дана строка:
Найдите все подстроки, в которых есть две и более одинаковые буквы подряд. -->
<!-- <?php
	$str = 'a aa aaa abab bbbb';
	echo preg_replace('#([a-z])+\g{-1}#', '!', $str);
?> -->
<!--
Дана строка:
Найдите все подстроки, в которых есть два одинаковых слова подряд. -->
<!-- <?php
	$str = 'aaa aaa bbb bbb ccc ddd';
	echo preg_replace('#([a-z]+)\ ([a-z]+)\1#', '!', $str);
?> -->

<!-- 217 Именованные карманы в регулярках PHP -->
<!--
Пусть с помощью preg_match мы хотим разбить дату на день, месяц и год. Используем для этого карманы: -->
<!-- <?php
	$str = '2025-10-29';
	$reg = '#(\d{4})-(\d{2})-(\d{2})#';

	preg_match($reg, $str, $match);
	var_dump($match); // выведет ['2025-10-29', '2025', '10', '29']
?> -->
<!-- Как вы видите, в результате мы получаем массив, в котором в нулевом элементе будет вся дата, в первом - год,
во втором - месяц, в третьем - день.
Иногда, однако, было бы удобно получить содержимое карманов в виде ассоциативного массива.
То есть в нашем случае было бы неплохо получить вот такой массив:
[
	'year'  => '2025',
	'month' => '10',
	'day'   => '29'
]
Для этого в регулярках существует специальный синтаксис.
Вот он: (?<name>pattern), где pattern - это регулярка, а name - это имя кармана.
-->

<!-- Давайте перепишем нашу регулярку для даты через именованные карманы: -->
<!-- <?php
	$str = '2025-10-29';
	$reg = '#(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})#';
	preg_match($reg, $str, $match);
	echo '<pre>';
	print_r($match);
	echo '</pre>';
?> -->
<!--
Описанные именованные карманы имеют еще несколько альтернативных синтаксисов: (?P<name>pattern) и (?'name'pattern). -->

<!-- Дана строка со временем:
Положите часы, минуты и секунды в отдельные именованные карманы.
Напишите функцию, которая в массиве с результатом удалит все нумерованные карманы, оставив только именованные. -->
<!-- <?php
	$str = '12:59:59';
	$reg = '#(?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2})#';
	preg_match($reg, $str, $match);
	foreach ($match as $key => $value) {
        if (is_int($key)) {
            unset($match[$key]);
        }
    }
	echo '<pre>';
	print_r($match);
	echo '</pre>';
?> -->

<!-- 218 Именованные карманы внутри регулярки PHP -->

<!-- Вспомним, как мы пользовались карманами в самом регулярном выражении: -->
<!-- <?php
	$res = preg_replace('#([a-z])\1#', '!', $str);
?> -->
<!-- Иногда бывают ситуации, когда удобнее обращаться к карману не по его номеру, а по имени. Для этого нам нужно дать карману имя: -->
<!-- <?php
	$res = preg_replace('#(?<letter>[a-z])#', '!', $str);
?> -->
<!-- Теперь мы можем обратиться к этому карману через синтаксис \k<name>, вот так: -->
<!-- <?php
	$res = preg_replace('#(?<letter>[a-z])\k<letter>#', '!', $str);
?> -->
<!-- Описанные именованные карманы имеют еще несколько альтернативных синтаксисов: (?P=name), \k'name', \k{name}. -->

<!-- Дана строка:
Найдите все подстроки со временем, в которых час совпадает с секундами. -->
<!-- <?php
$str = '12:59:59 12:59:12 09:45:09';
$res = preg_replace('#(?<hours>\d{2}):\d{2}:\g{hours}#', '!', $str);
echo $res;
?> -->

<!-- 219 Общий номер карманов в регулярках PHP -->
<!--
Рассмотрим следующую ситуацию. Пусть у нас есть переменная с годом, который может изменяться от 1990 до 2099.
Пусть мы хотим получать последние две цифры года в карман. Напишем соответствующую регулярку: -->
<!-- <?php
	$reg = '#19(9\d)|20(\d\d)#';
?> -->
<!-- Нас, однако, здесь поджидает одно неудобство. Дело в том, что для годов прошлого века две цифры будут попадать в первый карман,
а для годов второго века - во второй. Посмотрим на примерах.
Вот первый вариант: -->
<!-- <?php
	$str = '1991';
	preg_match($reg, $str, $res);
	var_dump($res); // [1 => '91']
?> -->

<!-- А вот второй вариант: -->
<!-- <?php
	$str = '2021';
	preg_match($reg, $str, $res);
	var_dump($res); // [2 => '21']
?> -->
<!--
Пусть теперь мы хотим записать найденные цифры года в переменную.
Нас ждет проблема, ведь мы не знаем точно, с каким ключом забирать данные из кармана: -->
<!-- <?php
	$year = $res[1]; // нужен ключ или 1, или 2
?> -->

<!-- Можно решить проблему через условие: -->
<!-- <?php
	if (!empty($res[1])){
		$year = $res[1];
	} else{
		$year = $res[2];
	}
?> -->
<!-- Однако, есть решение попроще. Можно использовать специальную команду (?| ).
Все карманы, которые находятся внутри нее будут иметь один номер.
Давайте исправим нашу регулярку -->
<!-- <?php
	$reg = '#(?|19(\d)|20(\d\d))#';
?> -->

<!-- И теперь наш год точно будет в кармане с номером один: -->
<!-- <?php
	$year = $res[1];
?> -->

<!-- Даны строки с датами, в которых год может изменяться от 1990 до 2099:
Для каждой даты положите день в первый карман, месяц во второй, а последние две цифры года - в третий. -->
<!-- <?php
$arr = [ '30-11-1995', '29-10-1990', '31-12-2025' ];
$str=null;
foreach ($arr as $elem=>$key)
{
$str.=$key.' ';
}
echo '<br>'. $str . '<br>';
preg_match_all('#(?<days>\d{2})-(?<month>\d{2})-(?<years>19(9\d)|20([0-8]\d))#',$str,$res);
print_r ($res[1]);
echo '<br>';
print_r ($res[2]);
echo '<br>';
print_r ($res[3]);
?> -->
<!--
220 Позитивный и негативный просмотр в PHP -->
<!--
Иногда нужно решить задачу такого типа: найти строку 'aaa' и заменить ее на '!',
но только если после 'aaa' стоит 'x', а сам 'x' при этом не заменять.
Если мы попытаемся решить задачу 'в лоб', то у нас ничего не выйдет: -->
<!-- <?php
	preg_replace('#aaax#', '!', 'aaax'); // будет '!', а надо '!x'
?> -->

<!-- Просмотр вперед
Для решения задачи нужен способ сказать, что 'x' не следует заменять.
Делается это с помощью специальных скобок (?= ), которые просто смотрят, но не забирают с собой.
Эти скобки называются позитивный просмотр вперед.
Позитивный - так как 'x' (в нашем случае) должен быть - только тогда произойдет замена.
Давайте применим эти скобки для решения нашей задачи: -->
<!-- <?php
	preg_replace('#aaa(?=x)#', '!', 'aaax'); // вернет '!x'
?> -->

<!-- Есть и негативный просмотр вперед - (?! ) - он, наоборот, говорит, что чего-то должно не быть.
В следующем примере замена произойдет, только если после 'aaa' не стоит 'x': -->
<!-- <?php
	preg_replace('#aaa(?!x)#', '!', 'aaab'); // вернет '!b'
?> -->

<!-- Просмотр назад
Аналогичным образом есть позитивный просмотр назад - (?<= ).
В следующем примере замена произойдет, только если перед 'aaa' стоит 'x': -->
<!-- <?php
	preg_replace('#(?<=x)aaa#', '!', 'xaaa'); // вернет 'x!'
?> -->
<!--
И есть также негативный просмотр назад - (?<! ). В следующем примере замена произойдет, только если перед 'aaa' не стоит 'x': -->
<!-- <?php
	preg_replace('#(?<!x)aaa#', '!', 'baaa'); // вернет 'b!'
?> -->

<!--
Дана строка, содержащая имена функций:
Получите массив имен функций из строки. -->
<!-- <?php
	$str = 'func1() func2() func3()';
	$reg = '#func[1-9]\(\)(?=\s)#';
	preg_match($reg, $str, $match);
	print_r ($match);
?> -->

<!-- Дана строка с тегом:
Получите массив имен атрибутов этого тега. -->
<!-- <?php
	$str = '<a href="" class="eee" id="zzz">';
$reg = '#[a-z]+\s(?=\=)[\"[a-z]\s\"]#';
	preg_match($reg, $str, $match);
	print_r ($match);
?> -->

<!-- 221 Замена с коллбэком через регулярки в PHP -->

<!-- Пусть у нас есть следующая строка:
<?php
	$str = '2+3= 3+5= 7+8=';
?> -->
<!--
Пусть нам нужно найти все конструкции вида число+число= и сделать так, чтобы после равно появился результат сложения.
Для решения подобной задачи удобно воспользоваться функцией preg_replace_callback, которая работает аналогично функции preg_replace -
находит и заменяет по регулярному выражению, но позволяет выполнять дополнительные манипуляции с найденными кусочками. -->
<!--
Давайте попробуем на практике. Напишем, код, который поймает наши подстроки, при этом положив первое число в первый карман,
а второе - во второй: -->
<!-- <?php
	$str = '2+3= 3+5= 7+8=';

	preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
		print_r($match);
	}, $str);
?> -->
<!-- Идем дальше. Каждое совпадение будет заменено на то, что возвращает коллбэк через return.
Давайте для примера заменим каждую из искомых подстрок на знак '!' -->
<!-- <?php
	$str = '2+3= 3+5= 7+8=';
	$res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
		return '!';
	}, $str);
	echo $res; // выведет '! ! !'
?> -->

<!-- А теперь заменим каждую подстроку на сумму пары чисел в ней: -->
<!-- <?php
	$str = '2+3= 3+5= 7+8=';
	$res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
		return $match[1] + $match[2];
	}, $str);
	echo $res; // выведет '5 8 13'
?> -->

<!-- Получается, что наша задача почти решена. Осталось сделать так, чтобы перед суммой чисел оставалась искомая подстрока.
Для этого будем вставлять перед суммой содержимое нулевого кармана: -->
<!-- <?php
	$str = '2+3= 3+5= 7+8=';
	$res = preg_replace_callback('#(\d+)\+(\d+)=#', function($match) {
		return $match[0] . ($match[1] + $match[2]);
	}, $str);
	echo $res; // выведет '2+3=5 3+5=8 7+8=13'
?> -->

<!-- Дана строка с целыми числами. С помощью регулярки преобразуйте строку так, чтобы вместо этих чисел стояли их квадраты. -->
<!-- <?php
$str = '2*2= 3*3= 4*4=';
$res = preg_replace_callback('#(\d+)\*(\d+)=#', function($match){
	return $match[0] . ($match[1] * $match[2]);
}, $str);
echo $res;
?> -->

<!-- 222 Модификаторы регулярок в PHP -->

<!-- Как вы уже знаете, модификаторы представляют собой команды, которые пишутся после правого ограничителя регулярки.
Давайте посмотрим, что полезного можно сделать с их помощью. -->

<!-- 223 Игнорирование регистра регулярок в PHP -->

<!-- По умолчанию в регулярках регистр символов имеет значение. В следующем примере мы найдем только буквы в нижнем регистре: -->
<!-- <?php
	preg_replace('#[a-z]+#', '!', 'aaa bbb AAA'); // вернет '! ! AAA'
?> -->
<!-- Мы можем изменить такое поведение регулярки, использовав модификатор i. Исправим нашу регулярку в соответствии с этим: -->
<!-- <?php
	echo preg_replace('#[a-z]+#i', '!', 'aaa bbb AAA'); // вернет '! ! !'
?> -->

<!-- Упростите следующий код, использовав соответствующий модификатор: -->
<!-- <?php
	echo preg_replace('#[a-z]+#i', '!', 'aaa BBB');
?> -->

<!-- 224 Комментарии в регулярке в PHP -->
<!--
Модификатор x разрешает расставлять в регулярке произвольные пробелы и переводы строк.
Кроме того, символ решетки становится символом однострочного комментария (соотвественно, ограничители придется заменить на другие).
Давайте посмотрим на примере. Пусть у нас есть вот такая регулярка: -->
<!-- <?php
	preg_replace('#[a-z]+@[0-9]+#', '!', 'aaa@333');
?> -->
<!--
Давайте используем модификатор x и расставим в для каждой части нашей регулярки поясняющие комментарии: -->
<!-- <?php
	echo preg_replace('~
		[a-z]+ # буквы
		@      # символ собаки
		[0-9]+ # цифры
	~x', '!', 'aaa@333');
?> -->
<!--
225 Работа с юникодом в регулярках в PHP -->

<!-- Модификатор u, с которым вы уже сталкивались ранее, заставляет регулярку корректно работать с юникодом.
В частности, корректно обрабатывать кириллические строки: -->
<!-- <?php
	preg_replace('#[а-яё]#u', '!', 'яяя ййй ёёё');
?> -->

<!-- 226 Изменение жадности регулярок в PHP -->

<!-- Модификатор U делает так, что все операторы повторений станут по умолчанию нежадными,
а добавление ?, наоборот, будет добавлять им жадности: -->

<!-- <?php
	echo preg_replace('#x.+x#U', '!', 'xax xaax xaaax'); // вернет '! ! !'
?> -->

<!-- 227 Экранировка обычных символов в регулярках в PHP -->

<!-- Модификатор X делает так, что экранировка обычного символа приведет к ошибке.
Без этого оператора обычные символы можно экранировать, они все равно будут обозначать сами себя (исключение: цифры, они станут карманами).
Посмотрим на примере: -->
<!-- <?php
	echo preg_replace('#x\@x#X', '!', 'x@x x2x'); // ошибка, @ не спецсимвол
?> -->

<!-- 228 Несколько модификаторов регулярок в PHP -->
<!--
После ограничителя можно писать несколько модификаторов. Пример: -->
<!-- <?php
	echo preg_replace('#[a-z]+#iU', '!', 'aaa bbb AAA a6a');
?> -->

<!-- Расскажите, как меняют поведение регулярки модификаторы в следующем коде: -->
<!-- <?php
echo preg_replace('#[a-z]+#Uu', '!', 'aaa bbb ллл');
?> -->
<!--
Расскажите, как меняют поведение регулярки модификаторы в следующем коде: -->
<!-- <?php
	echo preg_replace('#[a-z]+#Xx', '!', 'aaa bbb a+a a@a');
?> -->

<!-- Расскажите, как меняют поведение регулярки модификаторы в следующем коде: -->
<!-- <?php
	echo preg_replace('#[а-яё]+#ui', '!', 'яяя ЙЙЙ ёёё');
?> -->